<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ride中引用Selenium2Library显示红色]]></title>
    <url>%2F2019%2F01%2F12%2Fride%E4%B8%AD%E5%BC%95%E7%94%A8Selenium2Library%E6%98%BE%E7%A4%BA%E7%BA%A2%E8%89%B2%2F</url>
    <content type="text"><![CDATA[刚刚学习自动化，原本想着先跟着网上来做个简单的例子吧，没想到在引用Selenium2Library就受到了阻碍了&gt;.&lt; 我在ride中引用Selenium2Library的库报红，说明没有引用成功。然后我就去网上查找相关问题。分析一下网上出现的几种问题 1.Selenium2Library名字填写时一定要记住S和L是大写的。如果是这个问题的话很容易就解决了。 2.没有安装robotframework-selenium2library，这个也很容易确认，进入cmd pip list 可以检查是否安装，如果没有安装可以根据 pip 命令安装 pip install robotframework-selenium2library。我是安装了还是有问题。 所以以上两种都不是我的问题。 没有办法我就安装了robotframework-requests，来验证是不是我安装的环境有问题，但是试下来，RequsetsLibrary可以在ride中正常引用。后来又看到了官网 https://github.com/robotframework/Selenium2Library说的Selenium2Library3.0也支持Python2.7 我就尝试着 按照官网上的升级pip 命令1pip install --upgrade --pre robotframework-selenium2library 安装成功后我立即启动了ride终于Selenium2Library引用成功了。 不过也可以先在Tools-View RIDE Log中查看报错的日志信息是什么]]></content>
      <categories>
        <category>自动化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RobotFramework RIDE桌面快捷方式制作]]></title>
    <url>%2F2019%2F01%2F10%2FRobotFramework%20RIDE%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[接上一篇笔记0.0 1.创建快捷方式 在桌面右键鼠标，弹出的菜单选择 新建-快捷方式，然后在请键入对象的位置输入这一行命令 D:\Python27\pythonw.exe -c “from robotide import main; main()” 注：根据自己安装python的路径，我的是在D盘的，还有双引号记得是英文格式哦，否则会启动不了哦 如图： 点击下一步，输入快捷方式的名称，根据自己需要随意命名就好。 点击完成后会在桌面生成图标 2.如果想要把图标换成机器人图标需要快捷方式上点击右键-属性，如图 点击“更改图标”，在浏览里找到目录D:\Python27\Lib\site-packages\robotide\widgets，里面有个robot.ico的图标（大家到自己的安装目录相同路径去找一下），如图 选它之后，点打开，确定之后再确定就可以了，效果如图 最后快捷方式就制作完成了，可以打开正常使用了。]]></content>
      <categories>
        <category>自动化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Robot Framework的环境搭建]]></title>
    <url>%2F2019%2F01%2F09%2FRobot%20Framework%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1.Python2.7安装下载地址：https://www.python.org/downloads/release/python-2715/ python-2.7.15.amd64.msi 下载完成后，选择安装路径自行安装即可。安装完成后注意配置系统环境变量path:配置Python27安装路径和Python27/Scripts路径。 2.Robot framework的安装RF框架是基于python的，所以一定要有python环境 安装方式选择一种即可： （1）exe包安装下载地址：https://pypi.python.org/pypi/robotframework/2.8.5#downloads robotframework-2.8.5.win-amd64.exe 直接双击下一步即可。 （2）pip命令安装pip install robotframework 3.wxPython 的安装作用：Wxpython 是python 非常有名的一个GUI库，因为RIDE 是基于这个库开发的，所以这个必须安装。 下载地址：http://sourceforge.net/projects/wxpython/files/wxPython/2.8.12.1/ wxPython2.8-win64-unicode-2.8.12.1-py27.exe 直接双击下一步即可。 4.Robot framework-ride作用：RIDE就是一个图形界面的用于创建、组织、运行测试的软件。 安装方式选一种即可： （1）包安装下载地址：https://pypi.python.org/pypi/robotframework-ride robotframework-ride-1.5.1.tar.gz 下载完成后将其解压，然后进入到解压后的文件路径进行安装123cd D:\robotframework-ride-1.5.1python setup.py install （2）pip安装1pip install robotframework-ride 5.Robot framework-selenium2library作用：RF-seleniumlibrary 可以看做RF版的selenium 库，selenium （webdriver）可以认为是一套基于web的规范（API），所以，RF 、appium 等测试工具都可以基于这套API进行页面的定位与操作。 下载地址：https://github.com/robotframework/Selenium2Library#readme Selenium2Library-master.zip 下载完成后将其解压，然后进入到解压后的文件路径进行安装 12cd D:\Selenium2Library-masterpython setup.py install 6.查看pybot版本12cd D:\Python27\Scriptspybot --version 7.启动RIDE 1.通过文件启动（双击D:\Python27\Lib\site-packages\robotide下的init.py文件） 2.通过命令启动（运行-&gt;ride.py回车/确认，打开ride.py文件之后（以python方式打开 ） 12cd D:\Python27\Scripts\python ride.py 3.将D:\Python27\Scripts\ride.py创建快捷键（具体怎么创建，详见下一篇笔记）建议创建快捷方式，方便使用 注：根据自己的python安装路径，我的是在D盘的]]></content>
      <categories>
        <category>自动化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[换了电脑如何使用hexo继续写博客]]></title>
    <url>%2F2019%2F01%2F02%2F%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[电脑中病毒了，换了系统，无法使用hexo再发布文章到个人博客，百度找教程0.0特此记录一下，万一哪天又中病毒了呢！ 一、安装必要软件 安装Git客户端 安装node.js 二、原文件拷贝将你原来电脑上个人博客目录下必要文件拷到你的新电脑上（比如D:/Blog目录下），注意无需拷全部，只拷如下几个目录：12345config.ymlpackage.jsonscaffolds/source/themes/ 三、安装 hexo在 cmd 下输入下面指令安装 hexo：1npm install hexo-cli -g 四、进入 D:/Blog 目录（你拷贝到新电脑的目录），输入下面指令安装相关模块12npm installnpm install hexo-deployer-git --save // 文章部署到 git 的模块 五、在github官网添加新电脑产生的秘钥 Github 添加 SSH Keys 首先在本地创建 SSH Keys:1$ ssh-keygen -t rsa -C "15754367707@163.com" 后面的邮箱即为 github 注册邮箱，也是登录 Github 的邮箱，之后会要求确认路径和输入密码，一路回车就行。 成功的话会在 ~/下生成 .ssh文件夹，进去，打开 id_rsa.pub，复制里面的key即可。 输入 eval “$(ssh-agent -s)” ，添加密钥到ssh-agent，再输入 ssh-add ~/.ssh/id_rsa ，添加生成的SSH key到ssh-agent 然后我们再次测试下公钥有没有添加成功：ssh -T git@github.com 六、测试 这时候使用 hexo s 基本可以看到你新添加的文章了。 七、部署发布文章123hexo clean // 清除缓存 网页正常情况下可以忽略此条命令hexo g // 生成静态网页hexo d // 开始部署]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter学习(二)元件的作用域与执行顺序]]></title>
    <url>%2F2018%2F07%2F15%2FJMeter%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E5%85%83%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一、元件的作用域&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JMeter中共有8类可被执行的元件（测试计划与线程组不属于元件），这些元件中，取样器是典型的不与其它元件发生交互作用的元件，逻辑控制器只对其子节点的取样器有效，而其它元件（config elements 、timers 、post-processors、assertions、listeners、）需要与取样器（sampler）等元件交互。 配置元件（config elements ） 元件会影响其作用范围内的所有元件。 前置处理程序（Per-processors） 元件在其作用范围内的每一个sampler元件之前执行。 定时器（timers ） 元件对其作用范围内的每一个sampler 有效。 后置处理程序（Post-processors） 元件在其作用范围内的每一个sampler元件之后执行。 断言（Assertions） 元件对其作用范围内的每一个sampler 元件执行后的结果执行校验。 监听器（Listeners） 元件收集其作用范围的每一个sampler元件的信息并呈现。 在Jmeter中，元件的作用域是靠测试计划的的树型结构中元件的父子关系来确定的，作用域的原则是： 取样器（sampler）元件不和其它元件相互作用，因此不存在作用域的问题。逻辑控制器（Logic Controller）元件只对其子节点中的取样器 和 逻辑控制器作用。除取样器 和逻辑控制器 元件外，其他6类元件，如果是某个sampler的子节点，则该元件公对其父子节点起作用。除取样器和逻辑控制器元件外的其他6类元件，如果其父节点不是sampler ，则其作用域是该元件父节点下的其他所有后代节点（包括子节点，子节点的子节点等）。 二、元件的执行顺序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解了元件有作用域之后，来看看元件的执行顺序，元件执行顺序的规则很简单，在同一作用域名范围内，测试计划中的元件按照如下顺序执行。 （1）配置元件（config elements ） （2）前置处理程序（Per-processors） （3）定时器（timers ） （4）取样器（Sampler） （5）后置处理程序（Post-processors） （除非Sampler 得到的返回结果为空）。 （6）断言（Assertions）（除非Sampler 得到的返回结果为空）。 （7）监听器（Listeners）（除非Sampler 得到的返回结果为空）。 关于执行顺序，有三点需要注意： 前置处理器、后置处理器和断言等元件只能对 取样器作用，因此，如果在它们的作用域内没有任何取样器，则不会被执行。 如果在同一作用域范围内有多个同一类型的元件，则这些元件按照它们在测试计划中的上下顺序一次执行。 一个断言在测试树中是分等级的。如果它的父元件是请求，它就被应用于那个请求。如果它的父元件是控制器，它就影响所有那个控制器下的所有请求。]]></content>
      <categories>
        <category>JMeter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JMeter学习(一)工具简单介绍]]></title>
    <url>%2F2018%2F07%2F14%2FJMeter%E5%AD%A6%E4%B9%A0-%E4%B8%80-%E5%B7%A5%E5%85%B7%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、JMeter 介绍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apache JMeter是100%纯JAVA桌面应用程序，被设计为用于测试客户端/服务端结构的软件(例如web应用程序)。它可以用来测试静态和动态资源的性能，例如：静态文件，Java Servlet,CGI Scripts,Java Object,数据库和FTP服务器等等。JMeter可用于模拟大量负载来测试一台服务器，网络或者对象的健壮性或者分析不同负载下的整体性能。同时，JMeter可以帮助你对你的应用程序进行回归测试。通过你创建的测试脚本和assertions来验证你的程序返回了所期待的值。为了更高的适应性，JMeter允许你使用正则表达式来创建这些assertions. JMeter与LoadRunner比较&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JMeter 是一款开源(有着典型开源工具特点：界面不美观)测试工具，虽然与LoadRunner相比有很多不足，比如：它结果分析能力没有LoadRunner详细；但它的优点也有很多： 开源，它是一款开源的免费软件，使用它你不需要支付任何费用， 小巧，相比LR的庞大（最新LR11将近4GB），它非常小巧，不需要安装，但需要JDK环境，因为它是使用java开发的工具。 功能强大，jmeter设计之初只是一个简单的web性能测试工具，但经过不段的更新扩展，现在可以完成数据库、FTP、LDAP、WebService等方面的测试。因为它的开源性，当然你也可以根据自己的需求扩展它的功能。两者最大的区别：jmeter不支持IP欺骗，而LR支持。JMeter缺点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用JMeter无法验证JS程序，也无法验证页面UI，所以必须要和Selenium配合来完成Web2.0应用的测试。 二、JMeter 下载安装1）JMeter安装 http://jmeter.apache.org/下载最新版本的JMeter，解压文件到任意目录 安装JDK，配置环境变量JAVA_HOME. 系统要求：JMeter2.11 需要JDK1.6以上的版本支持运行 JMeter可以运行在如下操作系统上：Unix，Windows和Open VMS. 避免在一个有空格的路径安装JMeter，这将导致远程测试出现问题。 2）JMeter插件安装 插件下载地址： http://jmeter-plugins.org/downloads/all/ 插件下载后解压：找到JMeterPlugins-Extras.jar,把JMeterPlugins-Extras.jar放到apache-jmeter-2.12\lib\ext目录。 三、JMeter 运行 进入bin目录运行jmeter.bat启动jmeter 注意：打开的时候会有两个窗口，JMeter的命令窗口和JMeter的图形操作界面，不可以关闭命令窗口。 JMeter的classpath: 如果你想添加其他JAR文件到JMeter的classpath中，你必须复制他们到lib目录中; 如果你开发了一个JMeter特定组件或有效的jar文件，复制到lib目录下的ext目录中。 打开之后显示的是中文，如果你想使用其他语言，比如英文，那么通过菜单选项-&gt;选择语言-&gt;英文即可，当然转为中文也是同样操作。 四、JMeter 测试计划元件打开Jmeter页面：包括测试计划。 1、Test Plan (测试计划) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用来描述一个性能测试，包含与本次性能测试所有相关的功能。也就说本的性能测试的所有内容是于基于一个计划的。 右键单击“测试计划”弹出菜单 2、Threads（Users）线程 用户 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然有三个添加线程组的选项，名字不一样， 创建之后，其界面是完全一样的。之前的版本只有一个线程组的名字。现在多一个setUp theread Group 与terDown Thread Group 1) setup thread group &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种特殊类型的ThreadGroup的，可用于执行预测试操作。这些线程的行为完全像一个正常的线程组元件。不同的是，这些类型的线程执行测试前进行定期线程组的执行。 setUp Thread Group类似于lr的init.可用于执行预测试操作。 2) teardown thread group. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种特殊类型的ThreadGroup的，可用于执行测试后动作。这些线程的行为完全像一个正常的线程组元件。不同的是，这些类型的线程执行测试结束后执行定期的线程组。 tearDown Thread Group类似于lr的end.可用于执行测试后动作。 3) thread group(线程组). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个就是我们通常添加运行的线程。通俗的讲一个线程组,，可以看做一个虚拟用户组，线程组中的每个线程都可以理解为一个虚拟用户。线程组中包含的线程数量在测试执行过程中是不会发生改变的。 3、测试片段（Test Fragment） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试片段元素是控制器上的一个种特殊的线程组，它在测试树上与线程组处于一个层级。它与线程组有所不同，因为它不被执行，除非它是一个模块控制器或者是被控制器所引用时才会被执行。 控制器 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JMeter有两种类型的控制器：取样器（sample）和逻辑控制器（Logic Controller），用这些原件来驱动处理一个测试。 4、取样器（Sampler） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取样器（Sampler）是性能测试中向服务器发送请求，记录响应信息，记录响应时间的最小单元，JMeter 原生支持多种不同的sampler ， 如 HTTP Request Sampler 、 FTP Request Sampler 、TCP Request Sampler 、 JDBC Request Sampler 等，每一种不同类型的 sampler 可以根据设置的参数向服务器发出不同类型的请求。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Jmeter的所有Sampler中，Java Request Sampler与BeanShell Requst Sampler是两种特殊的可定制的Sampler. 5、逻辑控制器（Logic Controller） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;逻辑控制器，包括两类无件，一类是用于控制test plan 中 sampler 节点发送请求的逻辑顺序的控制器，常用的有 如果（If）控制器 、 switch Controller 、Runtime Controller、循环控制器等。另一类是用来组织可控制 sampler 来节点的， 如 事务控制器、吞吐量控制器。 6、配置元件（Config Element） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置元件（config element）用于提供对静态数据配置的支持。CSV Data Set config 可以将本地数据文件形成数据池 （Data Pool），而对应于HTTP Request Sampler和 TCP Request Sampler等类型的配制无件则可以修改 Sampler的默认数据。 例如，HTTP Cookie Manager 可以用于对 HTTP Request Sampler 的 cookie 进行管理。 HTTP 请求默认值不会触发Jmeter发送http请求，而只是定义HTTP请求的默认属性。 7、定时器（Timer） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定时器（Timer）用于操作之间设置等待时间，等待时间是性能测试中常用的控制客户端QPS的手段。类似于LoadRunner里面的“思考时间”。 JMeter 定义了Bean Shell Timer、Constant Throughput Timer、固定定时器等不同类型的Timer。 8、前置处理器（Per Processors） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前置处理器用于在实际的请求发出之前对即将发出的请求进行特殊处理。例如，HTTP URL重写修复符则可以实现URL重写，当RUL中有sessionID 一类的session信息时，可以通过该处理器填充发出请求的实际的sessionID 。 9、后置处理器（Post Processors） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后置处理器是用于对Sampler 发出请求后得到的服务器响应进行处理。一般用来提取响应中的特定数据（类似LoadRunner测试工具中的关联概念）。例如，XPath Extractor 则可以用于提取响应数据中通过给定XPath 值获得的数据;正则表达式提取器，则可以提取响应数据中通过正则表达式获得的数据。 10、断言（Assertions） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;断言用于检查测试中得到的相应数据等是否符合预期，断言一般用来设置检查点，用以保证性能测试过程中的数据交互是否与预期一致。 11、监听器（Listener） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个监听器可不是用来监听系统资源的元件。它是用来对测试结果数据进行处理和可视化展示的一系列元件。 图形结果、查看结果树、聚合报告、用表格察看结果都是我们经常用到的元件。]]></content>
      <categories>
        <category>JMeter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[winscp上传文件发生错误码4的问题]]></title>
    <url>%2F2018%2F06%2F20%2Fwinscp%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%E7%A0%814%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于使用winscp 上传文件发生错误码4的问题，各种百度找资料，最后的原因竟然是磁盘容量不足。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换个物理分区，重新上传就好了。 所以下次遇到类似错误时，我觉得，对应磁盘的容量和权限也是一个排除的方向。]]></content>
      <categories>
        <category>学习中遇到问题及解决方法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[查看Linux系统配置的命令]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%9F%A5%E7%9C%8BLinux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一：CPU1[root@zhoumingyan /]# cat /proc/cpuinfo 二：内存1[root@zhoumingyan /]# cat /proc/meminfo 三：查看CPU位数1231.[root@zhoumingyan /]# getconf LONG_BIT2.[root@zhoumingyan /]# uname -i 四：查看Linux版本121.[root@zhoumingyan /]# cat /etc/issue2.[root@zhoumingyan /]# cat /proc/version 五：查看内核版本1[root@zhoumingyan /]# uname -a 六：主机名1[root@zhoumingyan /]# hostname 七：查看selinux情况1[root@zhoumingyan /]# sestatus 八：网络 IP 1[root@zhoumingyan /]# ifconfig 网关 1[root@zhoumingyan /]# cat /etc/sysconfig/network DNS 1[root@zhoumingyan /]# cat /etc/resolv.conf 修改HOST文件 1[root@zhoumingyan /]# cat /etc/hosts 九：磁盘和分区1[root@zhoumingyan /]# df -h 十：查看键盘布局1[root@zhoumingyan /]# cat /etc/sysconfig/keyboard 十一：查看默认语言1[root@zhoumingyan /]#cat /etc/sysconfig/i18n 十二：查看文件或目录在磁盘空间的大小1[root@zhoumingyan /]#du -h]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux 目录结构]]></title>
    <url>%2F2018%2F06%2F04%2FLinux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[/：根目录 /usr:包含所有的命令、程序库、文档和其它文件等。这些文件在正常操作下不会被改变的。这个目录也包含你的linux发行版本的主要的应用程序，如Netscape. /var:包含在正常操作中被改变的文件：假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等。这个目录中存放着那些不断在扩充着的东西，为了保持/usr的相对稳定，那些经常被修改的目录可以放在这个目录下，实际上许多系统管理员都是这样干的。顺带说一下系统的日志文件就在/var/log目录中。 /home：用户的主目录。这个目录在系统升级时应该保留。 /proc:是一个虚拟的目录，它是系统内存的映射。它们实际上并不存在磁盘上，也不占用空间。（用ls -l可以显示它们的大小）当查看这些文件时，实际上是访问存在内存中的信息，这些信息用于访问系统 /bin：系统启动时需要的执行文件(二进制),这些文件可以被普通用户使用。 /sbin：系统执行文件(二进制),这些文件不打算被普通用户使用。（普通用户仍然可以使用它们，但要指定目录） /etc:操作系统的配置文件目录 /root:系统管理员的Home目录 /dev：设备文件目录。Linux下设备被当成文件，这样一来硬件被抽象化，便于读写、网络共享以及需要临时装载到文件系统中。正常情况下，设备会有一个独立的目录。这些设备的内容会出现在独立的子目录下。Linux没有所谓的驱动符。 /lib：存放系统最基本的动态链接共享库 /boot:用于自举加载程序的文件。当计算机启动时，这些文件首先被加载。 /opt：可选的应用程序。 /tmp:临时文件。该目录会被自动清理干净。 /lost+found:在文件系统修复时恢复的文件。这个目录平时是空的，当系统不正常关机后，这里就成了无家可归的文件的避难所了。 /mnt:这个目录是空的，系统提供这个目录是让用户临时挂载别的文件系统。 小结： 本地管理员安装额外的软件安装在/usr/local目录下并符号链接在/usr/local/bin下的主执行程序。 系统的所有设置在/etc目录下。 不要修改根目录和/usr目录下的任何内容]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础常见面试题(二)]]></title>
    <url>%2F2017%2F10%2F29%2FJava%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1.构造器(Constructor)能否被override 构造器(Constructor)能被继承，因此不能重写Override，但可以被重载Overload。2.说说&amp;和&amp;&amp;的区别 &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。 &amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str != null &amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。if(x==33 &amp; ++y&gt;0) y会增长，if(x==33 &amp;&amp; ++y&gt;0) y不会增长 3.final、 finally、 finalize的区别。 final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用 4.说出一些常用的类、包、接口、请各举5个 常用的类：BufferedReader、BufferedWriter、FileReader、FileWirter、String、Integerjava.util.Date、System、Class、ArrayList、HashMap 常用的包：java.lang、java.io、java.util、java.sql、javax.servlet、org.apache.strtuts.action、org.hibernate 常用的接口：Set、List、Map、Document、Servlet、HttpServletRequest、HttpServletResponse、Transaction(Hibernate)、Session(Hibernate)、HttpSessionJava常用集合类：Collection (最基本的集合类)、Vector类、Stack类、HashTable类、HashMap类 LinkedList类、ArrayList类 5.说出ArrayList、Vector、 LinkedList的存储性能和特性 ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。 Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。 6.HashMap和Hashtable的区别 HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。 HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap就必须为之提供外同步。 Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。 7.List 和 Map 区别 一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合 List中存储的数据是有顺序，并且允许重复； Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。 8.Overload和Override的区别 Overload是重载的意思，Override是覆盖的意思，也就是重写。 重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。 重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法 9.面向过程和面向对象的区别 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了； 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。 如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。由此可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一 10.面向对象的特征 面向对象的编程语言有封装、继承 、抽象、多态等4个主要的特征。 1.封装封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的”高内聚、低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装比传统语言的封装更为清晰、更为有力。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个”模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。 例如，人要在黑板上画圆，这一共涉及三个对象：人、黑板、圆，画圆的方法要分配给哪个对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两个属性，人以后只是调用圆的画圆方法、表示给圆发给消息而已，画圆这个方法不应该分配在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。一个更便于理解的例子就是，司机将火车刹住了，刹车的动作是分配给司机，还是分配给火车，显然，应该分配给火车，因为司机自身是不可能有那么大的力气将一个火车给停下来的，只有火车自己才能完成这一动作，火车需要调用内部的离合器和刹车片等多个器件协作才能完成刹车这个动作，司机刹车的过程只是给火车发了一个消息，通知火车要执行刹车动作而已。 2.抽象抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个Person类，如下：12345 class Person&#123; String name; int age;&#125; 人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。 3.继承 在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。 4.多态 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。例如，下面代码中的UserDao是一个接口，它定义引用变量userDao指向的实例对象由daofactory.getDao()在执行的时候返回，有时候指向的是UserJdbcDao这个实现，有时候指向的是UserHibernateDao这个实现，这样，不用修改源代码，就可以改变userDao指向的具体类实现，从而导致userDao.insertUser()方法调用的具体代码也随之改变，即有时候调用的是UserJdbcDao的insertUser方法，有时候调用的是UserHibernateDao的insertUser方法：12UserDao userDao = daofactory.getDao();userDao.insertUser(user);]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础常见面试题(一)]]></title>
    <url>%2F2017%2F10%2F28%2FJava%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1.什么是Java虚拟机? 为什么Java被称作是 “平台无关的编程语言”?Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 2.JDK和JRE的区别是什么? Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。 3.“static”关键字是什么意思? Java中是否可以覆盖(override)一个private或者是static的方法? “static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。 Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 4.是否可以在static环境中访问非static变量? static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 5.Java支持的数据类型有哪些?什么是自动拆装箱? Java语言支持的8种基本数据类型是：byteshortintlongfloatdoublebooleanchar自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。 6.Java支持多继承么? Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。 7.接口和抽象类的区别是什么? Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于： 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。类可以实现很多个接口，但是只能继承一个抽象类类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。抽象类可以在不提供接口方法实现的情况下实现接口。Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。 8.什么是值传递和引用传递? 值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象. 一般认为,java内的传递都是值传递. 9.throw和throws有什么区别? throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。 10.计算Math.round(11.5)与Math.round(-11.5)分别等于多少? Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring第二天]]></title>
    <url>%2F2017%2F09%2F12%2FSpring%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[继续第一天 9.spring的扫描器管理Bean实际项目如果很大就会出现大量配置，我们使用扫描器可以解决这个问题扫描器扫描带有@Controller，@Service, @Repository，@Component的类@Controller：控制层的类@Service：服务层的类@Repository：数据层的类@Component：无法分层的类上以上注解标注的类的bean的id默认类名的首字符小写 10.spring和junit的整合第一步：引入spring的测试包 实现：123456789101112131415161718192021/** * @RunWith:指定spring对junit提供的一个运行器 * @ContextConfiguration：指定spring配置文件位置 * @author zhoumingyan * */@RunWith(value=SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;"classpath:ApplicationContext.xml"&#125;)public class TestSpring1 &#123; /** * 在junit的bean中注入UserService */ @Autowired UserService userService; @Test public void test2() &#123; userService.save(); &#125;&#125; 11.AOPAOP（Aspect Oriented Programming），面向切面编程，通过预编译的方式在运行期通过动态代理实现一种技术。AOP是OOP延续，利用AOP可以实现业务和切面的逻辑分离，降低耦合度。程序的重用性提高。 1.jdk动态代理JDK动态代理代理目标是接口实现类的形式代理的目标对象12345678910111213141516171819202122public class UserServiceImpl implements UserService &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public void save() &#123; System.out.println("保存用户"); &#125; @Override public void update() &#123; System.out.println("修改用户"); &#125;&#125; 代理：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class JDKProxy implements InvocationHandler &#123; /** * 指定代理目标对象 */ private Object targetObj; /** * 第一个参数：获得目标对象的类的加载器 * 第二个参数：获得目标对象的接口 * 第三个参数：设置回调对象，当前代理对象的方法被调用时，会委派该参数去调用invoke * @param targetObj * @return */ public Object createProxyInstance(Object targetObj)&#123; this.targetObj = targetObj; return Proxy.newProxyInstance(this.targetObj.getClass().getClassLoader(), this.targetObj.getClass().getInterfaces(), this); &#125; /** * proxy:代理类 * Method：要调用的业务方法 * Object[]：调用的业务方法的参数 * */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //获得目标对象的get方法 Method getMeth = this.targetObj.getClass().getMethod("getUser", null); //通过反射来调用getUser Object user = getMeth.invoke(targetObj, null); Object obj = null; if(user != null)&#123; //obj是业务方法返回的值 obj = method.invoke(this.targetObj, args); &#125;else&#123; System.out.println("您还没有登录"); &#125; return obj; &#125;&#125; 2.CGLIB动态代理CGLIB可以对普通类做动态代理，目标类不能是final，目标类里面的方法也不能是final12345678910111213141516171819202122public class UserServiceImpl &#123;//implements UserService &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public void save() &#123; System.out.println("保存用户"); &#125; public void update() &#123; System.out.println("修改用户"); &#125;&#125; 代理：123456789101112131415161718192021222324252627282930313233public class CGLIBProxy implements MethodInterceptor &#123; /** * 指定代理目标对象 */ private Object targetObj; public Object createProxyInstance(Object targetObj)&#123; this.targetObj = targetObj; Enhancer en = new Enhancer(); //设置代理类的父类 en.setSuperclass(this.targetObj.getClass()); //设置回调对象 en.setCallback(this); //创建代理类 return en.create(); &#125; @Override public Object intercept(Object arg0, Method method, Object[] arg2, MethodProxy arg3) throws Throwable &#123; Method getMeth = this.targetObj.getClass().getMethod("getUser", null); //通过反射来调用getUser Object user = getMeth.invoke(targetObj, null); Object obj = null; if(user != null)&#123; obj = method.invoke(this.targetObj, arg2); &#125;else&#123; System.out.println("您还没有登录"); &#125; return obj; &#125;&#125; 3.Spring的注解形式AOPAspect（切面）：对横切性关注点的一中抽象。Jionpoint（连接点）：要拦截的方法。Pointcut（切点）：是连接点的集合Advice(通知)：在连接点前后或异常情况来做的事情，前置通知，后置通知，返回通知，异常通知，环绕通知。Target（目标对象）：代理的目标对象Weave（织入）：切面应用到目标对象并且导致proxy对象创建的过程叫织入第一步：引入Spring的aop的包 第二步：引入头信息12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd"&gt; &lt;/beans&gt; 第三步：基于注解方式的切面声明123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd"&gt; &lt;!-- 开启以注解形式切面的驱动 --&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 第四步：切面定义创建一个类，在上加入@Aspect注解12345678910111213141516@Aspectpublic class PermAspect &#123; /** * 第一个*：拦截方法的返回值 * 第一个..:子包 * 第二个*：所有的类 * 第三个*：所有的方法 * 第二个..:所有的参数 */ @Pointcut("execution(* com.zmy.spring.service..*.*(..))") public void anyMethod()&#123; &#125; &#125; 前置通知12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*@Aspectpublic class PermAspect &#123; /** * 第一个*：拦截方法的返回值 * 第一个..:子包 * 第二个*：所有的类 * 第三个*：所有的方法 * 第二个..:所有的参数 */ /*@Pointcut(value="execution(* com.zmy.spring.service..*.*(..))") public void anyMethod()&#123; &#125;*/ /*@Pointcut(value="execution(* com.zmy.spring.service..*.*(..))&amp;&amp;args(param)", argNames="param") public void anyMethod(User user)&#123; &#125;*/ /*@Pointcut(value="execution(!java.lang.String com.zmy.spring.service..*.*(..))&amp;&amp;args(param)", argNames="param") public void anyMethod(User user)&#123; &#125;*/ @Pointcut(value="execution(!java.lang.String com.zmy.spring.service..*.*(com.zmy.spring.model.User,..))") public void anyMethod()&#123; &#125; /** * @Before前置通知 * anyMethod():指定前置通知的切点 * 拦截带有user参数的业务方法 * args中参数名必须和方法的参数名称一致 */ /*@Before(value="anyMethod()&amp;&amp;args(user)") public void preAdive(User user)&#123; System.out.println(user); user.setUsername("周铭艳"); System.out.println("执行前置通知"); System.out.println("------------------------------------------"); &#125;*/ /*@Before(value="anyMethod()&amp;&amp;args(param)", argNames="param") public void preAdive(User user1)&#123; System.out.println(user1); user1.setUsername("周铭艳"); System.out.println("执行前置通知"); System.out.println("------------------------------------------"); &#125;*/ /*@Before(value="anyMethod(param)", argNames="param") public void preAdive(User user1)&#123; System.out.println(user1); user1.setUsername("周铭艳"); System.out.println("执行前置通知"); System.out.println("------------------------------------------"); &#125;*/ @Before(value="anyMethod()") public void preAdive()&#123; System.out.println("执行前置通知"); System.out.println("------------------------------------------"); &#125; /*@Before(value="anyMethod()") public void preAdive()&#123; System.out.println("执行前置通知"); System.out.println("------------------------------------------"); &#125;*/ &#125; 后置通知定义一个void方法，在方法上加@After注解，在业务方法执行之后来执行，其余使用方法和前置拦截一样。返回通知：123456789101112/** * @AfterReturning:返回通知的注解，在返回通知里面可以对业务方法的返回值做最后的统一加工。 * pointcut：指定返回通知的切点 * returning：指定返回值和返回通知的方法的参数名称要一致 * * @param user */ @AfterReturning(pointcut="anyMethod()", returning="user") public void returnAdvice(User user)&#123; user.setUsername("周铭艳"); System.out.println("执行返回通知"); &#125; 例外通知我们主要使用例外通知做运行期监控，获得项目的异常信息1234567891011/** * @AfterThrowing：异常通知的注解 * pointcut：切点 * throwing：抛出的异常 * @param ex */ @AfterThrowing(pointcut="anyMethod()", throwing="ex") public void exceptionAdvice(Exception ex)&#123; System.out.println("执行例外通知"); ex.printStackTrace(); &#125; 环绕通知：123456789101112@Aspectpublic class PermAspect2 &#123; /** * 第一个*：拦截方法的返回值 * 第一个..:子包 * 第二个*：所有的类 * 第三个*：所有的方法 * 第二个..:所有的参数 */ @Pointcut(value="execution(* com.rl.spring.service..*.*(..))") public void anyMethod()&#123;&#125; 1234567891011121314151617181920212223242526 /** * 环绕通知：可以实现前置通知，后置通知，返回通知，例外通知的所有功能 * @Around：环绕通知的注解，指定切点 * @param jp:指定的连接点（拦截的业务方法） * @return */ @Around("anyMethod()") public Object doAroundAdvice(ProceedingJoinPoint jp) &#123; //获得拦截的业务方法的参数 Object[] args = jp.getArgs(); System.out.println("环绕通知----前"+"-------传递的参数:"+args[0]); Object obj = null; User user = null; try &#123; //执行业务方法，也可以使用无参数，返回值就是业务方法的返回值 obj = jp.proceed(args); user = (User) obj; &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; user.setUsername("周铭艳"); System.out.println("环绕通知----后"+"-------返回值："+obj); return obj; &#125; &#125; 4.使用配置文件做AOP配置：123456789101112131415161718192021222324252627282930313233&lt;aop:config&gt; &lt;!-- 切点配置： expression：切点的表达式 id：唯一标识 --&gt; &lt;aop:pointcut expression="execution(* com.zmy.spring.service..*.*(..))" id="mycut"/&gt; &lt;!-- 切面配置 ref：要关联的切面类 --&gt; &lt;aop:aspect ref="permApect"&gt; &lt;!-- 前置通知 method：切面类中方法 pointcut-ref：切点 --&gt; &lt;aop:before method="preAdvice" pointcut-ref="mycut"/&gt; &lt;!-- 后置通知 --&gt; &lt;aop:after method="afterAdvice" pointcut-ref="mycut"/&gt; &lt;!-- 返回通知 returning：业务方法返回的值 --&gt; &lt;aop:after-returning method="returnAdvice" pointcut-ref="mycut" returning="returnval"/&gt; &lt;!-- 例外外通 throwing:抛出的异常的变量名知 --&gt; &lt;aop:after-throwing method="exceptionAdvice" pointcut-ref="mycut" throwing="ex"/&gt; &lt;!-- 环绕通知 --&gt; &lt;aop:around method="aroundAdvice" pointcut-ref="mycut"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 切面：123456789101112131415161718192021222324252627282930313233343536373839404142public class PermAspect &#123; public void preAdvice(JoinPoint jp)&#123; Object[] args = jp.getArgs(); if(args.length &gt; 0) System.out.println("执行前置通知-----------业务参数："+args[0]); &#125; public void afterAdvice(JoinPoint jp)&#123; Object[] args = jp.getArgs(); if(args.length &gt; 0) System.out.println("执行后置通知-----------业务参数："+args[0]); &#125; public void returnAdvice(JoinPoint jp, Object returnval)&#123; if(returnval instanceof User)&#123; User user = (User) returnval; user.setUsername("周铭艳"); &#125; System.out.println("返回通知----------返回的值"+returnval); &#125; public void exceptionAdvice(JoinPoint jp, Exception ex)&#123; System.out.println("例外通知------------"); ex.printStackTrace(); &#125; public Object aroundAdvice(ProceedingJoinPoint jp)&#123; Object[] objs = jp.getArgs(); if(objs.length&gt;0) System.out.println("执行环绕通知前-----------业务参数："+objs[0]); Object obj = null; try &#123; obj = jp.proceed(); System.out.println("执行环绕通知后-----------业务参数："+objs[0]); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; 12.jdbcTemplate第一步：引入jdbc的包第二步：配置数据源123456789101112131415&lt;!-- 数据源配置 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring3.2_10"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;!-- 初始化的连接数 --&gt; &lt;property name="initialSize" value="1"&gt;&lt;/property&gt; &lt;!-- 连接池的最大连接数--&gt; &lt;property name="maxActive" value="5"&gt;&lt;/property&gt; &lt;!-- 最大的空闲的连接数 --&gt; &lt;property name="maxIdle" value="2"&gt;&lt;/property&gt; &lt;!-- 最小的空闲连接数 --&gt; &lt;property name="minIdle" value="1"&gt;&lt;/property&gt; &lt;/bean&gt; 第三步：建立t_user表 第四步：DAO1234567891011121314151617181920212223242526272829303132333435363738public class UserDaoImpl implements UserDao &#123; private DataSource dataSource; private JdbcTemplate jt; public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; this.jt = new JdbcTemplate(dataSource); &#125; @Override public void saveUser(User user) &#123; String sql = "insert into t_user values(null, ?, ?)"; jt.update(sql, new Object[]&#123;user.getUsername(), user.getPassword()&#125;); &#125; @Override public void updateUser(User user) &#123; String sql = "update t_user set username = ?, password=? where user_id = ?"; jt.update(sql, new Object[]&#123;user.getUsername(), user.getPassword(), user.getUserId()&#125;); &#125; @Override public User queryUserById(int userId) &#123; String sql = "select * from t_user t where t.user_id = ?"; User user = jt.queryForObject(sql, new Object[]&#123;userId&#125;, new UserRowMapper()); return user; &#125; @Override public List&lt;User&gt; queryUserAll() &#123; String sql = "select * from t_user"; List&lt;User&gt; userList = jt.query(sql, new UserRowMapper()); return userList; &#125;&#125; 13.事务控制1.什么是事务一荣俱荣，一损俱损，很多复杂的操作我们可以把它看成是一个整体，要么同时成功，要么同时失败。事务的四个特征ACID： 原子性（Atomic）：表示组成一个事务的多个数据库的操作的不可分割的单元，只有所有的操作成功才算成功，整个事务提交，其中任何一个操作失败了都是导致整个所有操作失败，事务会回滚。 一致性（Consistentcy）：事务操作成功后，数据库所处的状态和业务规则一致。如果A账户给B账户汇100，A账户减去100，B加上100，两个账户的总额是不变的。 隔离性（islation）：在多个数据库的操作相同的数据并发时，不同的事务有自己的数据空间，事务与事务之间不受干扰（不是绝对的）。干扰程度受数据库或者操作事务的隔离级别来决定，隔离级别越高，干扰就越低，数据的一致性越好，并发性就越差。 持久性（Druability）：一旦事务提交成功，数据就被持久化到数据库，不可以回滚。2.spring使用注解对事务的控制1.来处理事务传播特性第一步：配置事务管理器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; &lt;!-- Spring读取属性文件配置 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 数据源配置 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;uname&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;pword&#125;"&gt;&lt;/property&gt; &lt;!-- 初始化的连接数 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池的最大连接数--&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;!-- 最大的空闲的连接数 --&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 最小的空闲连接数 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="userDao" class="com.zmy.spring.dao.impl.OrderDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="detailDao" class="com.zmy.spring.dao.impl.DetailDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="userService" class="com.zmy.spring.service.impl.OrderServiceImpl"&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义事务的管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器的主键驱动 --&gt; &lt;tx:annotation-driven transaction-manager="txManager"/&gt;&lt;/beans&gt; 第二步：通过@Transactional来标注要使用事务的类或接口或方法，在项目中我们通常都会把事务开启在Service层，建议把注解标注在接口的实现类或者是方法上。注意：在Service层开启事务的时候，默认情况下，发生运行时异常会回滚，非运行时异常不会回滚。可以设置对指定的异常回滚rollbackFor或rollbackForClassName设置对哪些回滚noRollbackFor或noRollbackForClassName设置对哪些不回滚@Transactional的默认传播特性是reqired，实际项目中80%都是采用reqired。 事务的传播特性：REQUIRED：默认的传播特性，业务方法需要在一个事务中运行，如果一个方法已经处在一个事务中那么就加入到这个事务中，否则就会创建一个事务。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring第一天]]></title>
    <url>%2F2017%2F09%2F11%2FSpring%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[1.Spring介绍Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架。 1.控制反转（Ioc/DI）控制反转（Inversion of Control），就是应用本身不负责对象的创建和维护，对象和依赖对象创建完全交给Spring的容器去管理和维护，这个权利反转给容器。 2.面向切面(AOP)AOP(Aspect Oriented Programming)，通过预编译的方式在运行期使用动态代理的方式来实现的一种技术。 2.spring环境搭建第一步：创建java工程 第二步：引入包第三步：创建spring的配置文件 默认名称叫ApplicationContext.xml1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"&gt;&lt;/beans&gt; 第四步：创建bean123456789package com.zmy.spring.dao.impl;import com.zmy.spring.dao.UserDao;public class UserDaoImpl implements UserDao &#123;@Overridepublic void save() &#123;System.out.println("user被保存了"); &#125;&#125; Spring配置1&lt;bean id="userDao" class="com.zmy.spring.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt; 我们必须指定id，唯一标识，class就是bean的类的全路径 第五步：创建Spring的容器123456789101112131415@Testpublic void test() &#123;//初始化spring容器ApplicationContext ctx = new ClassPathXmlApplicationContext("ApplicationContext.xml");//获得beanUserDao userDao = (UserDao) ctx.getBean("userDao");userDao.save();&#125; 3.Bean的创建方式1.使用构造器创建使用构造器方式创建bean，要求bean必须要有默认的构造器，这是工作中最常用的方式。12345678910111213public class User&#123; private Integer userId; private String username; public User()&#123; System.out.println("user被创建"); &#125;public User(Integer userId,String username)&#123; super(); this.userId=userId; this.username=username;&#125;&#125;2.静态工厂方式创建提供静态工厂12345678910public class FactoryBean &#123; /** * 必须是静态方法 * @return */ public static User createUser()&#123; return new User(); &#125;&#125;配置：123456&lt;!-- id：唯一标识 class：静态工厂的类 factory-method:静态工厂的方法 --&gt; &lt;bean id="user" class="com.zmy.spring.factory.FactoryBean" factory-method="createUser"&gt;&lt;/bean&gt;3.实例工厂方式创建实例工厂：12345public class FactoryBean1 &#123; public User createUser()&#123; return new User(); &#125;&#125;配置：1234567&lt;!-- 通过Spring来定义实例工厂 --&gt; &lt;bean id="factoryBean" class="com.zmy.spring.factory.FactoryBean1"&gt;&lt;/bean&gt; &lt;!-- 指定要创建的bean factory-bean：指定实例工厂类， factory-method：工厂的创建bean的方法 --&gt; &lt;bean id="user" factory-bean="factoryBean" factory-method="createUser"&gt;&lt;/bean&gt;4.延迟加载 所有的bean默认情况下，非延迟加载的，是spring的容器创建的时候就把bean给创建出来了，我们getBean的时候直接从容器中去拿这个Bean就可以了是否延迟加载由lazy-init来控制，默认是false，如果变成true就在getBean的时候去创建user 5.bean的作用域 默认情况下，bean都是单例的，是容器初始化的时候被创建的，就这么一份Scope：singleton单例，prototype多例，默认使用singleton如果是singleton我们可以设置非延迟加载（容器初始化时创建bean）和延迟加载（getBean的时候才创建）方式创建bean如果是prototype我们没得选择只能是延迟加载方式创建（getBean的时候才创建） 6.bean的生命周期 通过两个方法来验证Init方法和destroyInit是bean被创建的时候被调用，主要做一些准备工作Destroy是bean被销毁的时候被调用，做清理工作Bean的生命周期和容器一致，容器被创建bean就被创建，容器销毁bean就被销毁在user中定义两个方法123456public void init()&#123; System.out.println("我出来了"); &#125; public void destroy()&#123; System.out.println("20年后又是一条好汉"); &#125; 配置：123456&lt;!-- init-method:bean被创建时调用 destroy-method:bean被销毁时调用 --&gt; &lt;bean id="user" class="com.zmy.spring.model.User" init-method="init" destroy-method="destroy"&gt;&lt;/bean&gt; 7.依赖注入1.常量注入123456789101112&lt;!-- bean的常量注入 --&gt; &lt;bean id="user" class="com.zmy.spring.model.User"&gt; &lt;!-- property:class里面的属性 name：属性名 --&gt; &lt;property name="userId" value="1"&gt;&lt;/property&gt; &lt;property name="username" value="zhoumingyan"&gt;&lt;/property&gt; &lt;property name="password" value="123"&gt;&lt;/property&gt; &lt;/bean&gt; 2.构造器注入构造器注入常量：123456789101112131415&lt;!-- 构造器方式注入 --&gt; &lt;bean id="user" class="com.zmy.spring.model.User"&gt; &lt;!-- index:构造方法的参数的索引顺序 type:构造方法的参数的类型（不是必须 的） value:值 --&gt; &lt;!-- &lt;constructor-arg index="0" type="java.lang.Integer" value="2"/&gt; &lt;constructor-arg index="1" type="java.lang.String" value="zhoumingyan"/&gt; &lt;constructor-arg index="2" type="java.lang.String" value="666"/&gt; --&gt; &lt;constructor-arg index="0" value="2"/&gt; &lt;constructor-arg index="1" value="zhumingyan"/&gt; &lt;constructor-arg index="2" value="666"/&gt; &lt;/bean&gt; 注入bean：第一步：给当前的bean（Service实现类）提供要注入的bean有参数的构造器，切记不要忘了把默认构造器显示的提供出来 1234567891011121314151617public class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserServiceImpl() &#123; &#125; public UserServiceImpl(UserDao userDao) &#123; super(); this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; 第二步做配置123456789101112&lt;!-- 定义UserDao的bean --&gt; &lt;bean id="userDao" class="com.zmy.spring.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt; &lt;!-- 定义UserService的Bean --&gt; &lt;bean id="userService" class="com.zmy.spring.service.impl.UserServiceImpl"&gt; &lt;!-- 通过构造器的方式指定注入的bean type：指定UserDao接口，不要指定实现类 ref：就是要注入的bean --&gt; &lt;constructor-arg index="0" type="com.zmy.spring.dao.UserDao" ref="userDao"/&gt; &lt;/bean&gt; 3.外部bean注入（90%使用）第一步：创建UserService，中有一个UserDao的属性，必须提供set方法12345678910111213141516171819public class UserServiceImpl implements UserService &#123; private UserDao userDao; /** * 外部bean的方式注入，必须提供要注入的bean的set方法 * @param userDao */ public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; 配置：123456789101112&lt;!-- 定义UserDao的bean --&gt; &lt;bean id="userDao" class="com.zmy.spring.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt; &lt;!-- 定义Service的bean --&gt; &lt;bean id="userService" class="com.zmy.spring.service.impl.UserServiceImpl"&gt; &lt;!-- 通过属性方式注入 name:bean的属性名 ref：要注入的bean --&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt; &lt;/bean&gt; 4.内部bean注入第一步：创建UserService，中有一个UserDao的属性，必须提供set方法12345678910111213141516171819public class UserServiceImpl implements UserService &#123; private UserDao userDao; /** * 外部bean的方式注入，必须提供要注入的bean的set方法 * @param userDao */ public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; 配置：UserDaoImpl它定义在UserService的内部，不能其他bean注入，比较少用12345&lt;bean id="userService" class="com.zmy.spring.service.impl.UserServiceImpl"&gt; &lt;property name="userDao"&gt; &lt;bean class="com.zmy.spring.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 5.集合注入都能注入：set，list，map，property，必须提供set方法12345678910111213141516171819202122232425262728293031323334353637383940414243public class CollectionInjection &#123; private Set&lt;String&gt; set; private List&lt;String&gt; list; private Map&lt;String, String&gt; map; private Properties prop; public Properties getProp() &#123; return prop; &#125; public void setProp(Properties prop) &#123; this.prop = prop; &#125; public Map&lt;String, String&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public List&lt;String&gt; getList() &#123; return list; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public Set&lt;String&gt; getSet() &#123; return set; &#125; public void setSet(Set&lt;String&gt; set) &#123; this.set = set; &#125;&#125; 配置：1234567891011121314151617181920212223242526&lt;bean id="ci" class="com.zmy.spring.model.CollectionInjection"&gt; &lt;property name="set"&gt; &lt;set&gt; &lt;value&gt;football&lt;/value&gt; &lt;value&gt;basketball&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;male&lt;/value&gt; &lt;value&gt;female&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="key1" value="value1"&gt;&lt;/entry&gt; &lt;entry key="key2" value="value2"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="prop"&gt; &lt;props&gt; &lt;prop key="name"&gt;周铭艳&lt;/prop&gt; &lt;prop key="job"&gt;学生&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 8.注解方式注入第一步：引入依赖包 第二步：引入约束文件12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;/beans&gt; 第三步：开启注解的驱动12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;!-- 开启注解的驱动 --&gt; &lt;context:annotation-config/&gt; &lt;bean id="userDao" class="com.rl.spring.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt; &lt;bean id="userService" class="com.rl.spring.service.impl.UserServiceImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 1.@Resource注解1.加在属性上在bean中定义要注入bean的属性，不需要提供set方法1234567891011public class UserServiceImpl implements UserService &#123; @Resource private UserDao userDao; @Override public void save() &#123; userDao.save(); &#125;&#125; Spring容器初始化的时候，@Resource注解首先按着@Resource属性的name（默认没有指定name的时候用变量名(userDao)）名称匹配跟spring容器中bean的id来匹配，默认不指定@Resource的name时，如果name匹配不上，就按着接口和实现类的关系来匹配，如果存在一个接口有多个实现类的关系的时候，我们必须指定@Resource的name属性来指定到底注入哪一个bean 如果指定了name，能找到就注入进来，如果找不到就会报错，不会按着类型进行匹配 @Resource注解并不是spring的注解是javax下的。2.加在set方法上在set方法上加@Resource注解默认不指定@Resource的name的时候，bean的id和如果下左边的三个框内的任意一个名称能匹配上就能注入。如果三个名字都匹配不上就会按着接口和实现类的关系来匹配，如果遇到两个实现类就会报错，这时要求@Resource的name 如果一旦指定了@Resource的name如果name匹配不上就直接报错，不会再去按着类型去匹配1234@Resource(name="userDaoRedis") public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; 2.@Autowired注解1.加在属性上@Autowired按着接口和实现类的关系来匹配的，如果存在多个接口的实现类的时候，我们必须要指定name来匹配，要结合@Qulifier的注解来指定value和bean的id匹配来注入2.加在set方法上]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[端口被占用问题]]></title>
    <url>%2F2016%2F11%2F15%2F%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[当我们同时安装了Oracle和Tomcat的时候，Tomcat启动时就会报错说端口被占用了。那么如何来解决呢?两种方法： 第一种方法就是修改我们的Tomcat的端口号，改成其他不冲突的即可。方便简单 第二种方法就是结束当前占用端口的进程，下面是具体步骤： 以我电脑进程为例： 1.打开cmd 输入 netstat -ano|findstr 8080 //说明：查看占用8080端口的进程 2.接着输入 taskkill /pid 2956 /f 2956是占用端口的进程 //说明：结束掉占用端口号的进程 但是呢这种方法只能是一时的，下次启动还是会占用的。个人认为修改端口较好。一次解决。]]></content>
      <categories>
        <category>学习中遇到问题及解决方法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅谈设计模式之单例模式]]></title>
    <url>%2F2016%2F07%2F02%2F%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[首先我们看一下什么是设计模式? 设计模式（Design pattern） 设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 设计模式分为三大类: 创建型模式 共五种：单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式。 结构型模式 共七种：适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式。 行为型模式 共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 接下来进入本篇的主题–单例模式（Singleton） 单例模式（Singleton） 单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例 在我们日常的工作中经常需要在应用程序中保持一个唯一的实例，例如：IO处理，数据库操作，配置文件，工具类，线程池，缓存，日志对象等，由于这些对象都要占用重要的系统资源，所以我们必须限制这些实例的创建或始终使用一个公用的实例，如果创造出来多个实例，就会导致许多问题，比如占用过多资源，不一致的结果等。 单例模式是23中设计模式中最简单的一种模式。它具有以下几个特点： 私有的构造方法 指向自己实例的私有静态引用 以自己实例为返回值的静态的公有的方法 单例模式根据实例化对象时机的不同分为两种：一种是饿汉式单例，一种是懒汉式单例。饿汉式单例在单例类被加载的时候，就实例化一个对象交给自己的引用；而懒汉式在调用取得实例方法的时候才会实例化对象。 单例模式的创建步骤 将默认的构造器私有化 在类中定义一个当前类的类型的静态属性，并且创建该当前类的对象。 提供一个静态的类方法来返回当前类的静态属性的对象。 代码如下：懒汉式单例123456789101112131415161718192021222324252627282930313233343536/** 懒汉模式*/ class Singleton&#123; private static Singleton s = new Singleton(); /** 创建私有构造器 */ private Singleton()&#123; &#125; /** 提供一个共外界来获得当前类的一个实例的类方法 注意：类方法所访问的类的属性一定是类属性 */ public static Singleton getInstance()&#123; return s; &#125;&#125;class TestSingleton&#123; public static void main(String [] args)&#123; Singleton s = Singleton.getInstance(); System.out.println(s); Singleton s1 = Singleton.getInstance(); System.out.println(s1); //无论调用多少次 所获得的内存空间永远是一个 &#125;&#125; 代码如下：饿汉式单例 12345678910111213141516171819202122232425262728293031323334353637/** 饿汉模式*/class Singleton1&#123; private static Singleton1 s = null; /** 创建私有构造器 */ private Singleton1()&#123; &#125; /** 提供一个共外界来获得当前类的一个实例的类方法 注意：类方法所访问的类的属性一定是类属性 */ public static Singleton1 getInstance()&#123; if(s == null)&#123; s = new Singleton1(); &#125; return s; &#125;&#125;class TestSingleton1&#123; public static void main(String [] args)&#123; Singleton1 s = Singleton1.getInstance(); System.out.println(s); Singleton1 s1 = Singleton1.getInstance(); System.out.println(s1); &#125;&#125; 两者的区别： 懒汉模式的特点是加载类时比较快，但运行时获取对象的速度比较慢，线程不安全 饿汉模式的特点是加载类时比较慢，但运行时获取对象的速度比较快，线程安全 单例模式的优点： 在内存中只有一个对象，节省内存空间 避免频繁的创建销毁对象，可以提高性能 避免对共享资源的多重占用 可以全局访问 其适用场景： 需要频繁实例化然后销毁的对象 创建对象时耗时过多或者耗资源过多，但又经常用到的对象 有状态的工具类对象 频繁访问数据库或文件的对象]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第4天static静态关键字和单例模式]]></title>
    <url>%2F2015%2F12%2F01%2F%E7%AC%AC4%E5%A4%A9static%E9%9D%99%E6%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、static关键字1.static关键字修饰在属性上 语法 语法：static数据类型 变量名 使用static修饰的属性我们认为是类的属性，不带static修饰的属性我们认为是对象的属性。 类属性访问 类的属性访问： 第一种方式：类名.类属性（推荐使用） 第二种方式：对象实例.类属性 应用场景 应用的场景：我们把常量一般定义成static，或者当前类创建的每一个对象都有相同的属性也可以把这种属性定义成static的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Person&#123; /** name和age都是对象属性 */ String name; int age; /** 人的数量，类属性 */ static int personNum; //static String file_name = "struts.xml" public void introduce()&#123; //通过对象实例来访问类属性 System.out.println("我叫"+this.name+"年龄是"+this.age+"编号"+this.personNum+"报到"); &#125; &#125;class StaticDemo&#123; public static void main(String [] args)&#123; //创建一个person的实例 Person p = new Person(); //给人的数量加一 Person.personNum++; p.name = "周铭艳"; p.age = 18; p.introduce(); //创建一个person的实例 Person p1 = new Person(); //给人的数量加一 Person.personNum++; p1.name = "鲁达"; p1.age = 30; p1.introduce(); //通过类名来访问类的属性 System.out.println("当前人数："+Person.personNum); //通过对象实例来访问类属性 System.out.println("当前人数："+p.personNum); &#125;&#125; 内存中的加载流程 上述代码在内存中的流程 生命周期 对象属性生命周期：创建对象的时候初始化对象属性（没有类属性早），当当前对象变成匿名对象时，jvm会回收该垃圾对象，对象属性随之消失。 类属性的生命周期：当Person.class被载入内存时personNum类属性就初始化了，jvm关闭类属性就消失了 二、static关键字修饰在方法上 语法 语法：public static 返回值（void） 方法名（数据类型1 变量1，数据类型2 变量2，….）{ 方法体 [return 结果]} Static修饰在方法上就是类方法。 类方法的访问 类方法访问： &lt;font color=&apos;red&apos;&gt;第一种方式：类名.类方法()推荐使用&lt;/font&gt; 第二种方式：对象实例.类方法() 类方法对属性的访问 访问对象属性：类方法是无论是通过类访问还是通过对象访问都不能直接访问对象属性的 12345678910111213class Demo&#123; int num = 50; static int num1 = 100; //类方法 public static void printNum()&#123; //System.out.println("我是一个静态方法"); System.out.println(num); &#125; &#125; 类方法对类属性的访问： 类方法对类属性的访问是可以的。 注意：对象方法和属性只能通过对象来调用。 类方法和类属性既可以通过类来调用也可以通过对象来调用。 类方法应用场景： 做工具类 做数组的工具类12345678910111213141516171819202122232425262728293031323334353637class ArrayUtils&#123; public static void sort(int [] array)&#123; for(int i = 0; i &lt; array.length -1 ; i++)&#123; for(int j = 0; j &lt; array.length - 1 -i; j++)&#123; if(array[j] &lt; array[j+1])&#123; int temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125; &#125; public static void printArray(int [] array)&#123; for(int i = 0; i &lt; array.length; i++)&#123; System.out.print(array[i]+"\t"); &#125; &#125; public static void main(String [] args)&#123; int [] array = &#123;97,12,190, 4, 52,98&#125;; //ArrayUtils.printArray(array); //ArrayUtils.sort(array); System.out.println(); //ArrayUtils.printArray(array); //在同一个类中可以不加类名去访问静态方法。如果是不同类之间来访问静态方法必须加类名 printArray(array); sort(array); System.out.println(); printArray(array); &#125;&#125; 2.单例模式设计模式：一共有23种设计模式 设计模式就是有经验的前人通过实践总结下来被大家公认的代码设计思想。 单例模式：这种模式只能产生一个对象。 应用场景非常多：比如windows的任务管理器，回收站，java中数据库连接池，spring中bean的管理等等。 1.单例模式的创建步骤 （1）将默认的构造器私有化 （2）在类中定义一个当前类的类型的静态属性，并且创建该当前类的对象。 （3）提供一个静态的类方法来返回当前类的静态属性的对象。 懒汉模式 12345678910111213141516171819202122232425262728293031323334/** 懒汉模式*/class Singleton&#123; private static Singleton s = new Singleton(); /** 创建私有构造器 */ private Singleton()&#123; &#125; /** 提供一个共外界来获得当前类的一个实例的类方法 注意：类方法所访问的类的属性一定是类属性 */ public static Singleton getInstance()&#123; return s; &#125;&#125;class TestSingleton&#123; public static void main(String [] args)&#123; Singleton s = Singleton.getInstance(); System.out.println(s); Singleton s1 = Singleton.getInstance(); System.out.println(s1); &#125;&#125; 饿汉模式 12345678910111213141516171819202122232425262728293031323334353637/** 饿汉模式*/class Singleton1&#123; private static Singleton1 s = null; /** 创建私有构造器 */ private Singleton1()&#123; &#125; /** 提供一个共外界来获得当前类的一个实例的类方法 注意：类方法所访问的类的属性一定是类属性 */ public static Singleton1 getInstance()&#123; if(s == null)&#123; s = new Singleton1(); &#125; return s; &#125;&#125;class TestSingleton1&#123; public static void main(String [] args)&#123; Singleton1 s = Singleton1.getInstance(); System.out.println(s); Singleton1 s1 = Singleton1.getInstance(); System.out.println(s1); &#125;&#125;]]></content>
      <categories>
        <category>Java基础笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第3天程序的流程控制]]></title>
    <url>%2F2015%2F11%2F18%2F%E7%AC%AC3%E5%A4%A9%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、判断结果 简单if 语法：if(条件判断表达式){ 执行语句 }如果条件判断的表达式返回值是true则可以执行if内部的语句，否则如果是false就不可以执行。 范例1：如果java考试成绩大于等于60及格 1234567891011121314class Demo1&#123; public static void main(String[] args)&#123; int score = 70; if(score &gt;= 60)&#123; System.out.println("及格"); &#125; System.out.println("程序结束"); &#125;&#125; if…else 语法：if(条件判断表达式){ 执行语句 }else{ 执行语句} 范例2：如果java考试成绩大于60及格，否则是不及格 12345678910111213141516class Demo1&#123; public static void main(String[] args)&#123; int score = 10; if(score &gt;= 60)&#123; System.out.println("及格"); &#125;else&#123; System.out.println("不及格"); &#125; System.out.println("程序结束"); &#125;&#125; 多重 if….else if…else 语法：if(条件判断表达式){ 执行语句 }else if(条件表达式1){ 执行语句 }else if(条件表达式2){ ….. }else{} 范例3：如果大于等于60小于等于85及格，大于等于85小于100优秀，如果等于100完美，其余的不及格。 1234567891011121314151617181920class Demo1&#123; public static void main(String[] args)&#123; int score = 100; if(score &gt;= 60 &amp;&amp; score &lt; 85)&#123; System.out.println("及格了"); &#125;else if(score &gt;= 85 &amp;&amp; score &lt; 100)&#123; System.out.println("优秀"); &#125;else if(score == 100)&#123; System.out.println("完美"); &#125;else&#123; System.out.println("不及格"); &#125; System.out.println("程序结束"); &#125;&#125; 范例: 如果工资大于3000D级，大于5000C级，大于7000B级，大于10000A级通过简单if组合的形式 1234567891011121314151617181920212223242526class Demo2&#123; public static void main(String[] args)&#123; int salary = 7000; if(salary &gt;= 3000 &amp;&amp; salary &lt; 5000)&#123; System.out.println("D级"); &#125; if(salary &gt;= 5000 &amp;&amp; salary &lt; 7000)&#123; System.out.println("C级"); &#125; if(salary &gt;= 7000 &amp;&amp; salary &lt; 10000)&#123; System.out.println("B级"); &#125; if(salary &gt;= 10000)&#123; System.out.println("A级"); &#125; &#125;&#125; 通过多重if实现 二、Switch分支判断Switch：由上到下用switch中的表达式和值进行比较，如果匹配成功就执行case后的语句，在执行break的时跳出switch，如果一个也没有匹配上就执行default默认情况。 Switch（表达式）{ case 常量1： 执行语句1； break； case 常量2： 执行语句2； break； …..default:执行语句 ；break；} 范例1：通过等级打印不同星1234567891011121314151617181920212223242526272829303132333435class Demo4&#123; public static void main(String[] args)&#123; /*** 等级1用☆ 等级2用☆☆ 等级3用☆☆☆ 等级4用☆☆☆☆ 等级4用☆☆☆☆☆ */ int grade = 0; switch(grade)&#123; case 1: System.out.println("☆"); break; case 2: System.out.println("☆☆"); break; case 3: System.out.println("☆☆☆"); break; case 4: System.out.println("☆☆☆☆"); break; case 5: System.out.println("☆☆☆☆☆"); break; default: System.out.println("输入错误"); break; &#125; &#125;&#125; Break可以省略不会报错，如果省略就会穿透执行语句（不管是否能匹配上），知道遇到一个break才会跳出，所以我们不建议省略break。 在jdk1.7之前，swtich的表达式只能是byte, short, char, int,但是1.7后可以使用String 范例2：计算指定年的月中有多少天123456789101112131415161718192021222324252627282930313233343536373839class Demo5&#123; public static void main(String[] args)&#123; //计算每一年的每一月有几天 int year = 2000; int month = 2; int day = 0; switch(month)&#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: day = 31; break; case 4: case 6: case 9: case 11: day = 30; break; case 2: if((year%400) == 0 || (year%4 == 0&amp;&amp; year%100 != 0))&#123; day = 29; &#125;else&#123; day = 28; &#125; break; default: break; &#125; System.out.println(year + "年"+ month+"月有"+day+"天"); &#125;&#125; 注意： Switch和多重if的区别： If可以做等值判断也可以做区间判断。 Switch只能做等值判断，不能做区间判断 三元运算符 语法：表达式1 关系运算符 表达式2？表达式3：表达式4 ？前面的表达式2如果运算的结果是true，整个表达式的结果就是表达式3 ？前面的表达式2如果运算的结果是false，整个表达式的结果就是表达式4 注意：三元运算符适合两个值的判断 12345678910111213141516171819202122class Demo6&#123; public static void main(String[] args)&#123; //如果gender=1我们genderText就是男，如果gender=2那么genderText=女 int gender = 1; char genderText = ' '; /* if(gender == 1)&#123; genderText = '男'; &#125;else if(gender == 2)&#123; genderText = '女'; &#125; System.out.println(genderText); */ //表达式1 赋值 表达式2 genderText = gender == 1?'男':'女'; System.out.println(genderText); &#125;&#125; 循环结构 循环：就是重复发生的过程（循环一般有重复的前提条件）。1.While语法：while(表达式){ 循环体 }表达式结果如果是true那么就执行循环体，如果是false就结束循环 范例：1123456789101112131415161718192021class Demo7&#123; public static void main(String[] args)&#123; /* 打印1到100之间的数字 分析： 循环条件：是否完成打印100次 循环操作：输出，自增 */ //循环变量，计数器 int i = 1; while(i &lt;= 100)&#123; System.out.println(i); //更改循环条件 i++; &#125; &#125;&#125; 范例：212345678910111213141516171819202122232425262728class Demo8&#123; public static void main(String[] args)&#123; /* 需求：打印1到100之间的所有的偶数和 分析： 循环条件：判断计数器是否小于等于100 循环操作：累加偶数和，更新计数器 */ //定义计数器 int i = 0; //定义偶数和的结果变量 int sum = 0; while(i &lt;= 100)&#123; //判断i是否是偶数 if(i%2 == 0)&#123; //累加偶数 sum += i; &#125; //更新计数器 i++; &#125; System.out.println(sum); &#125;&#125; do…while语法：*do{循环体 }while(表达式) 注意：do…while和while，前者是先执行循环体，后者是先判断在执行循环体。 范例1：123456789101112131415161718192021222324252627282930class Demo9&#123; public static void main(String[] args)&#123; /* 需求：打印100到1000之间的所有水仙花数。 234 分析： 循环条件：判断计数器是大于等于100小于1000 循环操作：更新计数器，判断是否是水仙花数。 */ int i = 100; do&#123; //获得个位数 int g = i%10; //获得十位数 int s = i/10%10; //获得百位数 int b = i/100; //判断是否是水仙花数 if((g*g*g + s*s*s + b*b*b) == i)&#123; System.out.println(i); &#125; i++; &#125;while(i &lt; 1000); &#125;&#125; 范例2：123456789101112131415161718192021222324252627282930class Demo10&#123; public static void main(String[] args)&#123; /* 需求：打印100到1000之间的所有夹心饼数。 如：191,838 分析： 循环条件：判断计数器是大于等于100小于1000 循环操作：更新计数器，判断是否是夹心饼干 */ int i = 100; do&#123; //获得个位数 int g = i%10; //获得百位数 int b = i/100; //判断是否是水仙花数 if(g == b)&#123; System.out.println(i); &#125; i++; &#125;while(i &lt; 1000); &#125;&#125; for 语法：for(表达式1; 表达式2; 表达式3){ 循环体 } 表达式1：计数器的初始化，它只初始化一次 表达式2：循环条件的判断，多次执行 表达式3：修改计数器，多次执行 范例1：1234567891011121314151617181920212223class Demo11&#123; public static void main(String[] args)&#123; /* 需求：打印1到100之间的所有的偶数和 分析： 循环条件：判断计数器是否小于等于100 循环操作：累加偶数和，更新计数器 */ //定义偶数和的结果变量 int sum = 0; for(int i = 0; i &lt;= 100; i++)&#123; if(i%2 == 0)&#123; sum += i; &#125; &#125; System.out.println(sum); &#125;&#125; 范例2：打印一个5行5列的☆12345678910111213141516171819202122class Demo12&#123; public static void main(String[] args)&#123; /* 需求：打印5行5列 的☆ 分析： 我们要使用2个循环 循环条件：判断计数器是否小于等于100 循环操作：累加偶数和，更新计数器 */ //定义偶数和的结果变量 for(int i = 0; i &lt; 5; i++)&#123; for(int j = 0; j &lt; 5; j++)&#123; System.out.print("☆"); &#125; System.out.println(); &#125; &#125;&#125; 范例2：打印乘法口诀1231*1=11*2=2 2*2=41*3=3 2*3=6 3*3=9 12345678910111213141516171819202122class Demo13&#123; public static void main(String[] args)&#123; /* 范例2：打印乘法口诀 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 ….. */ for(int i = 1; i &lt;=9; i++)&#123; for(int j = 1; j &lt;= i; j++)&#123; System.out.print(j+"*"+i+"="+j*i+"\t"); &#125; System.out.println(); &#125; &#125;&#125; 总结： 最重要的循环是while和for 如果循环开始之前就能确定循环次数我们建议使用for 如果循环次数不定建议使用while break Break用来跳出循环和switch12345678910111213141516171819class Demo14&#123; public static void main(String[] args)&#123; /** 需求：运动会上跑5000米，跑到第三圈时，抽筋了退赛 */ for(int i = 1; i &lt;= 10; i++)&#123; if(i == 3)&#123; System.out.println("抽筋了退出"); //跳出循环 break; &#125; System.out.println("我跑到第"+i+"圈"); &#125; &#125;&#125; continue 也是来控制循环，在某次循环的时候放弃，后续的接着循环。123456789101112131415161718class Demo15&#123; public static void main(String[] args)&#123; /** 需求：一周上五天班，然后我周三请假一天 */ for(int i = 1; i &lt;= 5; i++)&#123; if(i == 3)&#123; System.out.println("周三肚子疼请假"); //跳出本次循环，接着下一次循环 continue; &#125; System.out.println("今天星期"+i+"上班"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java基础笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第2天Java基础语法]]></title>
    <url>%2F2015%2F11%2F11%2F%E7%AC%AC2%E5%A4%A9Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、标识符 在java语言中，对各种变量，方法和类等要素命名时所使用的字符序列就是标识符。这些标识符有jdk定义好的，也有我们自己开发时候需要定义的. java中标识符由26个英文字符大小写，数字0-9，符号_ $。注意：数字不能开头。 java中是严格区分大小写 在实际写程序的过程中定义标识符遵守“见名之意”. 类名和接口的规范： 在上面的约束的命名规范的情况下，首字符要大写。如果由多个单词构成每个单词的首字符都大写。 XxxYyy 如：PersonService 变量名和方法名： 在上面的约束的命名规范的情况下，我们遵守单词首字符不要大写，如果由多个单词构成，从第二个单词起首字符都大写。这叫驼峰模式。 xxxYyyZzz 如：personDao 包名在上面的约束的命名规范的情况下，都小写。 xxx.yyy.zzz 常量 所有字符都大写，多个单词之间使用下划线来分隔。 XXX_YYY_ZZZ 二、关键字Jdk定义的标识符就是关键字，我们不可以使用。所以我们定义标识符的时候一定要避开关键字。 三、java中的注释注释就是给程序说明的作用，我们要养成写注释的良好习惯，增强代码的可读性。Jvm运行时注释不会被解析。Jvm会跳过注释。 多行注释：/…./,通常用于方法内的多行或者类的多行注释 1234567891011/*public static void main(String[] args)&#123; System.out.println("HelloWorld1"); System.out.println("HelloWorld1"); System.out.println("HelloWorld1"); System.out.println("HelloWorld1"); System.out.println("HelloWorld1"); &#125;*/ 单行注释语法：//，注释代码中的一行，建议大家放在要注释的代码的上面 文档注释：语法/*../,用于类的说明和方法的说明 1234567891011121314151617181920212223/** *这是我们第一个HelloWorld的程序 */class HelloWorld&#123; /** *这是这是我们的主方法 */ public static void main(String[] args)&#123; //输出helloWorld System.out.println("HelloWorld1"); //输出helloWorld1 System.out.println("HelloWorld1"); /* System.out.println("HelloWorld1"); System.out.println("HelloWorld1"); System.out.println("HelloWorld1"); */ &#125;&#125; 四、数据类型1.基本数据类型 基本数据类型概述 根据不同的数据类型可以划分内存的存储的空间大小，不同的类型就是数据类型 整数的基本类型 byte 最小存储整数的空间 1字节 short 2字节 int 4字节 long 最大存储整数的空间 8字节 byte和short计算时产生的结果默认是int类型 小数的基本类型 flout 4字节 double 8字节 如果整型数据在计算的时候结果出现了小数，结果类型默认是double 建议使用double 字符数据类型char 2字节如：‘a‘，’周‘ 布尔数据类型 boolean true false 一共8种数据类型。 定义变量 语法：数据类型 变量名 = 值; 我们对变量的操作：取值和存值。1234567class Demo1&#123; public static void main(String[] args)&#123; //数据类型 变量名 = 值; int age = 10; System.out.println(age); &#125; &#125; 变量的定义位置：定义在方法中或者语句块中。 变量的一定要赋初始值，否则使用该变量的时候会报错的。 变量的作用范围：只在当前的大括号内有效，大括号外的所有程序不能使用该变量，所以这种变量也称为局部变量。123456789101112131415161718192021222324252627282930313233343536class Demo2&#123; public static void main(String[] args)&#123; //字节数据类型 byte workYear = 10; //短整型 short salary = 2000; //数据类型 变量名 = 值; int age = 30; //长整型,在定义长长整型的数据时在值后面加上l long empTime = 10000000l; //小数类型float,float类型的数值后面一定要有f float price = 45.6f; //小数类型double,建议在值的后面加d double totalPrice = 10000.5d; //布尔数据类型 boolean isMarry = false; //字符类型 char sex = '男'; System.out.println("工作年限："+workYear); System.out.println("月薪："+salary); System.out.println("年龄："+age); System.out.println("入职时长："+empTime); System.out.println("单价："+price); System.out.println("总价："+totalPrice); System.out.println("是否结婚："+isMarry); System.out.println("性别："+sex); &#125; &#125; 这八种数据类型是有默认值的。这个默认值如果在变量中不能使用的，必须是在类的属性中使用，因为类的属性可以不赋初始化值。 基本数据类型转换 八种数据类型除了布尔类型以外都可以相互的转换。 1.自动类型转换 基本数据类型在计算的时候都会向数值范围大的方向转换 byte—short–int —-long–float—double 所有的byte类型和short类型和char值运算的时候都会提供成int类型。 如果计算中一个操作数据类型是long，另一个数的空间小于等于long，那么结果就是long 如果计算中一个操作数据类型是float，另一个数的空间小于等于float，那么结果就是float 如果计算中一个操作数据类型是double，另一个数的空间小于等于double，那么结果就是double 2.强制转换 当大容量类型的变量向小容量的类型去转换需要强制转换。 语法：（目标类型）值1234567891011121314151617181920212223242526272829//在java程序中同一个范围内变量名字不能重复 int i3 = 97; //把int类型的数据强制转换成byte byte b3 = (byte)i3; //把int类型的数据强制转换成short short s3 = (short)i3; //把int类型的数据强制转换成char char c3 = (char)i3; System.out.println(b3); System.out.println(s3); System.out.println(c3); int i4 = 200; //注意如果被转换的值超过了要转换的值的最大值，转换时精度就损失了，不准确。 byte b4 = (byte)i4; System.out.println(b4); //把long类型的数据转换成int long l4 = 10000l; int i5 = (int)l4; System.out.println(i5); //把小数float转换成整型，直接把小数舍弃（非四舍五入） float f1 = 12.5f; int i6 = (int)f1; System.out.println(i6); //把小数double转换成整型，直接把小数舍弃（非四舍五入） double d1 = 15.5f; int i7 = (int)d1; System.out.println(i7); 思考： byte b1 = 3，b2=4, b; b = b1 + b2;//报错，因为byte类型计算完毕后会自动提升为int类型。 b= 4+3;//不会报错，因为int类型的常量相加只要没有达到byte的上限就可以。 2.引用数据类型 五、运算符 算数运算符 四则运算：+，-，*，/ 给数值变量自身加1或减一 123456789101112131415161718192021222324252627282930313233343536373839class Demo4&#123; public static void main(String[] args)&#123; //定义两个int类型的变量 int a = 30; int b = 20; System.out.println("a+b="+(a+b)); System.out.println("a-b="+(a-b)); System.out.println("a*b="+(a*b)); //整数之间做除法叫取整30/20=1.5,要把小数位舍弃 System.out.println("a/b="+(a/b)); //++, -- //a++起到了给a加1的作用 a++; //会输出a加1之后的值 System.out.println(a); //a--起到了给a减1的作用 a--; //会输出a减一1之后的值 System.out.println(a); //如果我后++或者后--和用变量在同一句代码中使用，是先使用a变量，再做加1或者减一 System.out.println(a--); System.out.println(a) //起到了给变量a加1的作用 --a; System.out.println(a); //如果我前++或者前--和用变量在同一句代码中使用，是先做加1或者减一，再使用a变量 System.out.println(--a); &#125; &#125; 赋值运算符 =，+=，-=，*=，/=, %= =：将左边的数值赋给右边的变量 +=：int x = 2；x+=3;相当于x=x+3 12345678910111213141516171819202122232425262728293031class Demo5&#123; public static void main(String[] args)&#123; //把20这个值赋给a变量 int a = 20; //+=,相当于a = a + 5; //a = a + 5; a+=5; System.out.println(a); //-=,相当于a = a - 5; a-=5; System.out.println(a); //*=,相当于a = a * 5; a*=5; System.out.println(a); ///=,相当于a = a / 5; a/=5; System.out.println(a); //%=,相当于a = a % 5; a%=5; System.out.println(a); &#125; &#125; 比较运算符 ==，!=, &gt;, &gt;=, &lt;, &lt;= ==:等于 !=:不等于 &gt;:大于 &gt;=:大于等于&lt;:小于&lt;=:小于等于 12345678910111213141516171819class Demo6&#123; public static void main(String[] args)&#123; int a = 19; int b = 10; //比较运算符的结果是布尔类型true，false System.out.println("a==b:"+(a==b)); System.out.println("a!=b:"+(a!=b)); System.out.println("a&gt;b:"+(a&gt;b)); System.out.println("a&lt;b:"+(a&lt;b)); System.out.println("a&gt;=b:"+(a&gt;=b)); System.out.println("a&lt;=b:"+(a&lt;=b)); &#125; &#125; 逻辑运算符 &amp;，|，^, &amp;&amp;, ||，！ 应用场景：如果某个结果需要多个条件满足或者部分条件满足的判断时使用。 &amp;: 用于连接多个表达式的判断，true&amp;true=true，&amp;两边的表达式都要参与计算。 |:用于连接多个表达式的判断，false|false=false, &amp;两边的表达式都要参与计算 短路逻辑（效率高） &amp;&amp;:用于连接多个表达式的判断, true&amp;&amp;true=true，如果第一个表达式能决定整个表达式的结果第二个表达式就不计算了。 ||:用于连接多个表达式的判断, false||false=false，如果第一个表达式能决定整个表达式的结果第二个表达式就不计算了。^:用于连接多个表达式的判断,如果两个表达式相同就是false，不同是true，两边都参加计算 （了解）！：取反 12345678910111213141516171819202122232425class Demo7&#123; public static void main(String[] args)&#123; int java = 90; int sql = 70; //只有java和sql打分都大于90分才合格 //System.out.println(java&gt;=90&amp;(sql++) &gt;= 90); //System.out.println(java&gt;=90|(sql++) &gt;= 90); //短路与，如果第一个表达式是false，后面的表达式就不需要判断了，效率高 //System.out.println(java&gt;=90&amp;&amp;(sql++) &gt;= 90); //短路或，如果第一个表达式是true，后面的表达式就不需要判断了，效率高 //System.out.println(java&gt;=90||(sql++) &gt;= 90); //异或了解 //System.out.println(java&gt;=90^(sql++) &gt;= 90); //System.out.println(sql); //如果对于表达式取反需要通过括号括上。 System.out.println(!(java &gt; 80)); &#125; &#125;]]></content>
      <categories>
        <category>Java基础笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第1天计算机基础初识JAVASE]]></title>
    <url>%2F2015%2F10%2F15%2F%E7%AC%AC1%E5%A4%A9%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%88%9D%E8%AF%86JAVASE%2F</url>
    <content type="text"><![CDATA[一、计算机语言概述计算机能识别的语言： 机器语言：由0和1组成的可以被电脑理解，人很难理解。 汇编语言：由汇编软件把汇编语言翻译成机器语言然后电脑可以理解，人可以理解。 高级语言：与人类的自然语言很接近，由高级语言的编译器来把高级语言翻译成机器语言，然后计算机来运行，java，c，c++,…. 二、Java概述1995年诞生于sun公司，2009被Oracle收购。 Java语言的特点： 简洁有效：面向对象，简单易学。 java跨平台：java写好的程序可以在不同平台来运行，一次编译处处运行。Java为每一个平台提供jvm（java virtual machine）。 适合分布式计算：java语言具有强大的，易于使用的互联网能力，非常适合大型的互联网分布式项目。 Java分支 javase: 前身j2se,2005年后改成javase javame：前身是j2me,2005改成javame，给移动设备做支持，目前基本上淘汰了。 javaee：前身j2ee，企业级应用技术开发支持 三、Java开发环境的介绍和搭建 JRE：java runtime environment java运行环境，JRE包括java虚拟机（jvm java virtual machine）和java程序所需要核心的类库。如果先要运行java程序，计算机中安装JRE就可以了。 JDK：java development kit JDK是给开发人员使用的，JDK包含了JRE，所以我们只要安装JDK就可以了。 JDK的安装 注意，安装JDK时不要有中文路径。 环境变量的介绍 配置环境变量步骤： 此电脑右键属性——高级系统设置—–高级——-环境变量 用户范围的环境变量：给当前操作系统登录的用户使用系统环境变量：给所有用户使用。 环境变量的配置：当我们在命令行中执行javac的时候，我们发现无法执行，就是因为当前的目录下没有javac的命令。如果想要在任意目录执行我们必须配置环境变量Path，path中的路径就是我们可以在任意的目录来执行程序，如果当前目录不存在程序就去path中去查找 环境变量的第二种配置方式（强烈推荐使用） 首先创建java_home: C:\Program Files\Java\jdk1.7.0_45指定bin的上一层目录然后在path中通过%%来引入java_home,然后在path中指定bin的目录 建议把环境变量配置在用户的环境变量中。 第一个java程序HelloWorld 推荐大家使用UtralEditor Java文件是以.java为后缀，类名要和文件名一致，类名的首字母要大写，然后在类中写入主方法，大括号一定是成对出现，类和方法之间要有缩进，方法和方法体之间也要有缩进，缩进使用Tab键，不要使用空格。除了带有大括号的代码行，每一行结尾都要有分号 12345678910class HelloWorld&#123;/** 主方法*/public static void main(String[] args)&#123;//输出字符串HelloWorldSystem.out.println("HelloWorld"); &#125;&#125; Java文件是不能直接运行的，必须要编译成.class二进制文件，然后才能运行。我们需要开启命令行来编译和运行。]]></content>
      <categories>
        <category>Java基础笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2015%2F10%2F02%2FHello-World%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
