<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ride中引用Selenium2Library显示红色]]></title>
    <url>%2F2019%2F01%2F12%2Fride%E4%B8%AD%E5%BC%95%E7%94%A8Selenium2Library%E6%98%BE%E7%A4%BA%E7%BA%A2%E8%89%B2%2F</url>
    <content type="text"><![CDATA[刚刚学习自动化，原本想着先跟着网上来做个简单的例子吧，没想到在引用Selenium2Library就受到了阻碍了&gt;.&lt; 我在ride中引用Selenium2Library的库报红，说明没有引用成功。然后我就去网上查找相关问题。分析一下网上出现的几种问题 1.Selenium2Library名字填写时一定要记住S和L是大写的。如果是这个问题的话很容易就解决了。 2.没有安装robotframework-selenium2library，这个也很容易确认，进入cmd pip list 可以检查是否安装，如果没有安装可以根据 pip 命令安装 pip install robotframework-selenium2library。我是安装了还是有问题。 所以以上两种都不是我的问题。 没有办法我就安装了robotframework-requests，来验证是不是我安装的环境有问题，但是试下来，RequsetsLibrary可以在ride中正常引用。后来又看到了官网 https://github.com/robotframework/Selenium2Library说的Selenium2Library3.0也支持Python2.7 我就尝试着 按照官网上的升级pip 命令1pip install --upgrade --pre robotframework-selenium2library 安装成功后我立即启动了ride终于Selenium2Library引用成功了。 不过也可以先在Tools-View RIDE Log中查看报错的日志信息是什么]]></content>
      <categories>
        <category>自动化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[robotframework Ride的快捷方式启动RIDE]]></title>
    <url>%2F2019%2F01%2F10%2FRobotFramework%20RIDE%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[接上一篇笔记0.0 1.创建快捷方式 在桌面右键鼠标，弹出的菜单选择 新建-快捷方式，然后在请键入对象的位置输入这一行命令 D:\Python27\pythonw.exe -c “from robotide import main; main()” 注：根据自己安装python的路径，我的是在D盘的，还有双引号记得是英文格式哦，否则会启动不了哦 如图： 点击下一步，输入快捷方式的名称，根据自己需要随意命名就好。 点击完成后会在桌面生成图标 2.如果想要把图标换成机器人图标需要快捷方式上点击右键-属性，如图 点击“更改图标”，在浏览里找到目录D:\Python27\Lib\site-packages\robotide\widgets，里面有个robot.ico的图标（大家到自己的安装目录相同路径去找一下），如图 选它之后，点打开，确定之后再确定就可以了，效果如图 最后快捷方式就制作完成了，可以打开正常使用了。]]></content>
      <categories>
        <category>自动化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Robot Framework的环境搭建]]></title>
    <url>%2F2019%2F01%2F09%2FRobot%20Framework%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1.Python2.7安装下载地址：https://www.python.org/downloads/release/python-2715/ python-2.7.15.amd64.msi 下载完成后，选择安装路径自行安装即可。安装完成后注意配置系统环境变量path:配置Python27安装路径和Python27/Scripts路径。 2.Robot framework的安装RF框架是基于python的，所以一定要有python环境 安装方式选择一种即可： （1）exe包安装下载地址：https://pypi.python.org/pypi/robotframework/2.8.5#downloads robotframework-2.8.5.win-amd64.exe 直接双击下一步即可。 （2）pip命令安装pip install robotframework 3.wxPython 的安装作用：Wxpython 是python 非常有名的一个GUI库，因为RIDE 是基于这个库开发的，所以这个必须安装。 下载地址：http://sourceforge.net/projects/wxpython/files/wxPython/2.8.12.1/ wxPython2.8-win64-unicode-2.8.12.1-py27.exe 直接双击下一步即可。 4.Robot framework-ride作用：RIDE就是一个图形界面的用于创建、组织、运行测试的软件。 安装方式选一种即可： （1）包安装下载地址：https://pypi.python.org/pypi/robotframework-ride robotframework-ride-1.5.1.tar.gz 下载完成后将其解压，然后进入到解压后的文件路径进行安装123cd D:\robotframework-ride-1.5.1python setup.py install （2）pip安装1pip install robotframework-ride 5.Robot framework-selenium2library作用：RF-seleniumlibrary 可以看做RF版的selenium 库，selenium （webdriver）可以认为是一套基于web的规范（API），所以，RF 、appium 等测试工具都可以基于这套API进行页面的定位与操作。 下载地址：https://github.com/robotframework/Selenium2Library#readme Selenium2Library-master.zip 下载完成后将其解压，然后进入到解压后的文件路径进行安装 12cd D:\Selenium2Library-masterpython setup.py install 6.查看pybot版本12cd D:\Python27\Scriptspybot --version 7.启动RIDE 1.通过文件启动（双击D:\Python27\Lib\site-packages\robotide下的init.py文件） 2.通过命令启动（运行-&gt;ride.py回车/确认，打开ride.py文件之后（以python方式打开 ） 12cd D:\Python27\Scripts\python ride.py 3.将D:\Python27\Scripts\ride.py创建快捷键（具体怎么创建，详见下一篇笔记）建议创建快捷方式，方便使用 注：根据自己的python安装路径，我的是在D盘的]]></content>
      <categories>
        <category>自动化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[换了电脑如何使用hexo继续写博客]]></title>
    <url>%2F2019%2F01%2F02%2F%E6%8D%A2%E4%BA%86%E7%94%B5%E8%84%91%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E7%BB%A7%E7%BB%AD%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[电脑中病毒了，换了系统，无法使用hexo再发布文章到个人博客，百度找教程0.0特此记录一下，万一哪天又中病毒了呢！ 一、安装必要软件 安装Git客户端 安装node.js 二、原文件拷贝将你原来电脑上个人博客目录下必要文件拷到你的新电脑上（比如D:/Blog目录下），注意无需拷全部，只拷如下几个目录：12345config.ymlpackage.jsonscaffolds/source/themes/ 三、安装 hexo在 cmd 下输入下面指令安装 hexo：1npm install hexo-cli -g 四、进入 D:/Blog 目录（你拷贝到新电脑的目录），输入下面指令安装相关模块12npm installnpm install hexo-deployer-git --save // 文章部署到 git 的模块 五、在github官网添加新电脑产生的秘钥 Github 添加 SSH Keys 首先在本地创建 SSH Keys:1$ ssh-keygen -t rsa -C "15754367707@163.com" 后面的邮箱即为 github 注册邮箱，也是登录 Github 的邮箱，之后会要求确认路径和输入密码，一路回车就行。 成功的话会在 ~/下生成 .ssh文件夹，进去，打开 id_rsa.pub，复制里面的key即可。 输入 eval “$(ssh-agent -s)” ，添加密钥到ssh-agent，再输入 ssh-add ~/.ssh/id_rsa ，添加生成的SSH key到ssh-agent 然后我们再次测试下公钥有没有添加成功：ssh -T git@github.com 六、测试 这时候使用 hexo s 基本可以看到你新添加的文章了。 七、部署发布文章123hexo clean // 清除缓存 网页正常情况下可以忽略此条命令hexo g // 生成静态网页hexo d // 开始部署]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter学习(二)元件的作用域与执行顺序]]></title>
    <url>%2F2018%2F07%2F15%2FJMeter%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E5%85%83%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一、元件的作用域&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JMeter中共有8类可被执行的元件（测试计划与线程组不属于元件），这些元件中，取样器是典型的不与其它元件发生交互作用的元件，逻辑控制器只对其子节点的取样器有效，而其它元件（config elements 、timers 、post-processors、assertions、listeners、）需要与取样器（sampler）等元件交互。 配置元件（config elements ） 元件会影响其作用范围内的所有元件。 前置处理程序（Per-processors） 元件在其作用范围内的每一个sampler元件之前执行。 定时器（timers ） 元件对其作用范围内的每一个sampler 有效。 后置处理程序（Post-processors） 元件在其作用范围内的每一个sampler元件之后执行。 断言（Assertions） 元件对其作用范围内的每一个sampler 元件执行后的结果执行校验。 监听器（Listeners） 元件收集其作用范围的每一个sampler元件的信息并呈现。 在Jmeter中，元件的作用域是靠测试计划的的树型结构中元件的父子关系来确定的，作用域的原则是： 取样器（sampler）元件不和其它元件相互作用，因此不存在作用域的问题。逻辑控制器（Logic Controller）元件只对其子节点中的取样器 和 逻辑控制器作用。除取样器 和逻辑控制器 元件外，其他6类元件，如果是某个sampler的子节点，则该元件公对其父子节点起作用。除取样器和逻辑控制器元件外的其他6类元件，如果其父节点不是sampler ，则其作用域是该元件父节点下的其他所有后代节点（包括子节点，子节点的子节点等）。 二、元件的执行顺序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解了元件有作用域之后，来看看元件的执行顺序，元件执行顺序的规则很简单，在同一作用域名范围内，测试计划中的元件按照如下顺序执行。 （1）配置元件（config elements ） （2）前置处理程序（Per-processors） （3）定时器（timers ） （4）取样器（Sampler） （5）后置处理程序（Post-processors） （除非Sampler 得到的返回结果为空）。 （6）断言（Assertions）（除非Sampler 得到的返回结果为空）。 （7）监听器（Listeners）（除非Sampler 得到的返回结果为空）。 关于执行顺序，有三点需要注意： 前置处理器、后置处理器和断言等元件只能对 取样器作用，因此，如果在它们的作用域内没有任何取样器，则不会被执行。 如果在同一作用域范围内有多个同一类型的元件，则这些元件按照它们在测试计划中的上下顺序一次执行。 一个断言在测试树中是分等级的。如果它的父元件是请求，它就被应用于那个请求。如果它的父元件是控制器，它就影响所有那个控制器下的所有请求。]]></content>
      <categories>
        <category>JMeter</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter学习(一)工具简单介绍]]></title>
    <url>%2F2018%2F07%2F14%2FJMeter%E5%AD%A6%E4%B9%A0-%E4%B8%80-%E5%B7%A5%E5%85%B7%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、JMeter 介绍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apache JMeter是100%纯JAVA桌面应用程序，被设计为用于测试客户端/服务端结构的软件(例如web应用程序)。它可以用来测试静态和动态资源的性能，例如：静态文件，Java Servlet,CGI Scripts,Java Object,数据库和FTP服务器等等。JMeter可用于模拟大量负载来测试一台服务器，网络或者对象的健壮性或者分析不同负载下的整体性能。同时，JMeter可以帮助你对你的应用程序进行回归测试。通过你创建的测试脚本和assertions来验证你的程序返回了所期待的值。为了更高的适应性，JMeter允许你使用正则表达式来创建这些assertions. JMeter与LoadRunner比较&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JMeter 是一款开源(有着典型开源工具特点：界面不美观)测试工具，虽然与LoadRunner相比有很多不足，比如：它结果分析能力没有LoadRunner详细；但它的优点也有很多： 开源，它是一款开源的免费软件，使用它你不需要支付任何费用， 小巧，相比LR的庞大（最新LR11将近4GB），它非常小巧，不需要安装，但需要JDK环境，因为它是使用java开发的工具。 功能强大，jmeter设计之初只是一个简单的web性能测试工具，但经过不段的更新扩展，现在可以完成数据库、FTP、LDAP、WebService等方面的测试。因为它的开源性，当然你也可以根据自己的需求扩展它的功能。两者最大的区别：jmeter不支持IP欺骗，而LR支持。JMeter缺点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用JMeter无法验证JS程序，也无法验证页面UI，所以必须要和Selenium配合来完成Web2.0应用的测试。 二、JMeter 下载安装1）JMeter安装 http://jmeter.apache.org/下载最新版本的JMeter，解压文件到任意目录 安装JDK，配置环境变量JAVA_HOME. 系统要求：JMeter2.11 需要JDK1.6以上的版本支持运行 JMeter可以运行在如下操作系统上：Unix，Windows和Open VMS. 避免在一个有空格的路径安装JMeter，这将导致远程测试出现问题。 2）JMeter插件安装 插件下载地址： http://jmeter-plugins.org/downloads/all/ 插件下载后解压：找到JMeterPlugins-Extras.jar,把JMeterPlugins-Extras.jar放到apache-jmeter-2.12\lib\ext目录。 三、JMeter 运行 进入bin目录运行jmeter.bat启动jmeter 注意：打开的时候会有两个窗口，JMeter的命令窗口和JMeter的图形操作界面，不可以关闭命令窗口。 JMeter的classpath: 如果你想添加其他JAR文件到JMeter的classpath中，你必须复制他们到lib目录中; 如果你开发了一个JMeter特定组件或有效的jar文件，复制到lib目录下的ext目录中。 打开之后显示的是中文，如果你想使用其他语言，比如英文，那么通过菜单选项-&gt;选择语言-&gt;英文即可，当然转为中文也是同样操作。 四、JMeter 测试计划元件打开Jmeter页面：包括测试计划。 1、Test Plan (测试计划) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用来描述一个性能测试，包含与本次性能测试所有相关的功能。也就说本的性能测试的所有内容是于基于一个计划的。 右键单击“测试计划”弹出菜单 2、Threads（Users）线程 用户 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然有三个添加线程组的选项，名字不一样， 创建之后，其界面是完全一样的。之前的版本只有一个线程组的名字。现在多一个setUp theread Group 与terDown Thread Group 1) setup thread group &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种特殊类型的ThreadGroup的，可用于执行预测试操作。这些线程的行为完全像一个正常的线程组元件。不同的是，这些类型的线程执行测试前进行定期线程组的执行。 setUp Thread Group类似于lr的init.可用于执行预测试操作。 2) teardown thread group. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种特殊类型的ThreadGroup的，可用于执行测试后动作。这些线程的行为完全像一个正常的线程组元件。不同的是，这些类型的线程执行测试结束后执行定期的线程组。 tearDown Thread Group类似于lr的end.可用于执行测试后动作。 3) thread group(线程组). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个就是我们通常添加运行的线程。通俗的讲一个线程组,，可以看做一个虚拟用户组，线程组中的每个线程都可以理解为一个虚拟用户。线程组中包含的线程数量在测试执行过程中是不会发生改变的。 3、测试片段（Test Fragment） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试片段元素是控制器上的一个种特殊的线程组，它在测试树上与线程组处于一个层级。它与线程组有所不同，因为它不被执行，除非它是一个模块控制器或者是被控制器所引用时才会被执行。 控制器 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JMeter有两种类型的控制器：取样器（sample）和逻辑控制器（Logic Controller），用这些原件来驱动处理一个测试。 4、取样器（Sampler） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取样器（Sampler）是性能测试中向服务器发送请求，记录响应信息，记录响应时间的最小单元，JMeter 原生支持多种不同的sampler ， 如 HTTP Request Sampler 、 FTP Request Sampler 、TCP Request Sampler 、 JDBC Request Sampler 等，每一种不同类型的 sampler 可以根据设置的参数向服务器发出不同类型的请求。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Jmeter的所有Sampler中，Java Request Sampler与BeanShell Requst Sampler是两种特殊的可定制的Sampler. 5、逻辑控制器（Logic Controller） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;逻辑控制器，包括两类无件，一类是用于控制test plan 中 sampler 节点发送请求的逻辑顺序的控制器，常用的有 如果（If）控制器 、 switch Controller 、Runtime Controller、循环控制器等。另一类是用来组织可控制 sampler 来节点的， 如 事务控制器、吞吐量控制器。 6、配置元件（Config Element） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置元件（config element）用于提供对静态数据配置的支持。CSV Data Set config 可以将本地数据文件形成数据池 （Data Pool），而对应于HTTP Request Sampler和 TCP Request Sampler等类型的配制无件则可以修改 Sampler的默认数据。 例如，HTTP Cookie Manager 可以用于对 HTTP Request Sampler 的 cookie 进行管理。 HTTP 请求默认值不会触发Jmeter发送http请求，而只是定义HTTP请求的默认属性。 7、定时器（Timer） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定时器（Timer）用于操作之间设置等待时间，等待时间是性能测试中常用的控制客户端QPS的手段。类似于LoadRunner里面的“思考时间”。 JMeter 定义了Bean Shell Timer、Constant Throughput Timer、固定定时器等不同类型的Timer。 8、前置处理器（Per Processors） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前置处理器用于在实际的请求发出之前对即将发出的请求进行特殊处理。例如，HTTP URL重写修复符则可以实现URL重写，当RUL中有sessionID 一类的session信息时，可以通过该处理器填充发出请求的实际的sessionID 。 9、后置处理器（Post Processors） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后置处理器是用于对Sampler 发出请求后得到的服务器响应进行处理。一般用来提取响应中的特定数据（类似LoadRunner测试工具中的关联概念）。例如，XPath Extractor 则可以用于提取响应数据中通过给定XPath 值获得的数据;正则表达式提取器，则可以提取响应数据中通过正则表达式获得的数据。 10、断言（Assertions） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;断言用于检查测试中得到的相应数据等是否符合预期，断言一般用来设置检查点，用以保证性能测试过程中的数据交互是否与预期一致。 11、监听器（Listener） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个监听器可不是用来监听系统资源的元件。它是用来对测试结果数据进行处理和可视化展示的一系列元件。 图形结果、查看结果树、聚合报告、用表格察看结果都是我们经常用到的元件。]]></content>
      <categories>
        <category>JMeter</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[winscp上传文件发生错误码4的问题]]></title>
    <url>%2F2018%2F06%2F20%2Fwinscp%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%E7%A0%814%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于使用winscp 上传文件发生错误码4的问题，各种百度找资料，最后的原因竟然是磁盘容量不足。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换个物理分区，重新上传就好了。 所以下次遇到类似错误时，我觉得，对应磁盘的容量和权限也是一个排除的方向。]]></content>
      <categories>
        <category>学习中遇到问题及解决方法</category>
      </categories>
      <tags>
        <tag>WinScp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看Linux系统配置的命令]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%9F%A5%E7%9C%8BLinux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一：CPU1[root@zhoumingyan /]# cat /proc/cpuinfo 二：内存1[root@zhoumingyan /]# cat /proc/meminfo 三：查看CPU位数1231.[root@zhoumingyan /]# getconf LONG_BIT2.[root@zhoumingyan /]# uname -i 四：查看Linux版本121.[root@zhoumingyan /]# cat /etc/issue2.[root@zhoumingyan /]# cat /proc/version 五：查看内核版本1[root@zhoumingyan /]# uname -a 六：主机名1[root@zhoumingyan /]# hostname 七：查看selinux情况1[root@zhoumingyan /]# sestatus 八：网络 IP 1[root@zhoumingyan /]# ifconfig 网关 1[root@zhoumingyan /]# cat /etc/sysconfig/network DNS 1[root@zhoumingyan /]# cat /etc/resolv.conf 修改HOST文件 1[root@zhoumingyan /]# cat /etc/hosts 九：磁盘和分区1[root@zhoumingyan /]# df -h 十：查看键盘布局1[root@zhoumingyan /]# cat /etc/sysconfig/keyboard 十一：查看默认语言1[root@zhoumingyan /]#cat /etc/sysconfig/i18n 十二：查看文件或目录在磁盘空间的大小1[root@zhoumingyan /]#du -h]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 目录结构]]></title>
    <url>%2F2018%2F06%2F04%2FLinux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[/：根目录 /usr:包含所有的命令、程序库、文档和其它文件等。这些文件在正常操作下不会被改变的。这个目录也包含你的linux发行版本的主要的应用程序，如Netscape. /var:包含在正常操作中被改变的文件：假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等。这个目录中存放着那些不断在扩充着的东西，为了保持/usr的相对稳定，那些经常被修改的目录可以放在这个目录下，实际上许多系统管理员都是这样干的。顺带说一下系统的日志文件就在/var/log目录中。 /home：用户的主目录。这个目录在系统升级时应该保留。 /proc:是一个虚拟的目录，它是系统内存的映射。它们实际上并不存在磁盘上，也不占用空间。（用ls -l可以显示它们的大小）当查看这些文件时，实际上是访问存在内存中的信息，这些信息用于访问系统 /bin：系统启动时需要的执行文件(二进制),这些文件可以被普通用户使用。 /sbin：系统执行文件(二进制),这些文件不打算被普通用户使用。（普通用户仍然可以使用它们，但要指定目录） /etc:操作系统的配置文件目录 /root:系统管理员的Home目录 /dev：设备文件目录。Linux下设备被当成文件，这样一来硬件被抽象化，便于读写、网络共享以及需要临时装载到文件系统中。正常情况下，设备会有一个独立的目录。这些设备的内容会出现在独立的子目录下。Linux没有所谓的驱动符。 /lib：存放系统最基本的动态链接共享库 /boot:用于自举加载程序的文件。当计算机启动时，这些文件首先被加载。 /opt：可选的应用程序。 /tmp:临时文件。该目录会被自动清理干净。 /lost+found:在文件系统修复时恢复的文件。这个目录平时是空的，当系统不正常关机后，这里就成了无家可归的文件的避难所了。 /mnt:这个目录是空的，系统提供这个目录是让用户临时挂载别的文件系统。 小结： 本地管理员安装额外的软件安装在/usr/local目录下并符号链接在/usr/local/bin下的主执行程序。 系统的所有设置在/etc目录下。 不要修改根目录和/usr目录下的任何内容]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hwclock命令]]></title>
    <url>%2F2018%2F04%2F22%2Fhwclock%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hwclock命令123hwclock 显示当前时间hwclock --hctosys 将系统时钟调整为与目前的硬件时钟一致。hwclock --set --date=&lt;日期与时间&gt; 设定硬件时钟。 1、date1234查看系统时间# date设置系统时间# date --set “07/07/06 10:19" （月/日/年 时:分:秒） 2、hwclock/clock12345678查看硬件时间# hwclock --show或者# clock --show设置硬件时间# hwclock --set --date="07/07/06 10:19" （月/日/年 时:分:秒）或者# clock --set --date="07/07/06 10:19" （月/日/年 时:分:秒） 3、硬件时间和系统时间的同步 按照前面的说法，重新启动系统，硬件时间会读取系统时间，实现同步，但是在不重新启动的时候，需要用hwclock或clock命令实现同步。 硬件时钟与系统时钟同步：12345# hwclock --hctosys（hc代表硬件时间，sys代表系统时间）或者# clock --hctosys系统时钟和硬件时钟同步：# hwclock --systohc 或者# clock --systohc]]></content>
      <categories>
        <category>常用linux命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[du命令]]></title>
    <url>%2F2018%2F04%2F20%2Fdu%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[dudu命令是检查硬盘使用情况，统计文件或目录及子目录使用硬盘的空间大小。参数的不同组合，可以更快的提高工作效率，以下仅列出了经常使用到的参数，如需更详细的信息，请用man du命令来获得。 1．命令格式1du [选项][文件] 2．命令功能显示每个文件和目录的磁盘使用空间。 3．命令参数说明1234567891011121314151617181920-a显示所有目录或文件的大小-b以byte为单位，显示目录或文件的大小-c显示目录或文件的总和-k以KB为单位输出-m以MB为单位输出-s仅显示目录或文件的总计数值-h以K,M,G为单位，提高信息可读性-x跳过不同的文件系统目录-S显示目录的大小，但不含子目录大小。-D显示指定符号链接的源文件大小 12345678910111213显示目录或者文件所占空间# du显示指定文件所占空间#du 文件名查看指定目录所占空间#du 目录名显示文件和目录#du -ah 目录名显示两个目录所占磁盘空间大小#du yum yum.bakevar目录中的某个文件太大，就可以使用如下命令查看# du -s /var/*|sort -nrSort -nr 从大到小排列倒叙排列，将占用磁盘空间最大的文件最先显示出来 举例： 1.查看当前目录下所有目录以及子目录的大小123#du -h ."."代表当前目录下。也可以换成一个明确的路径-h 表示用K/M/G的形式显示 2.查看当前目录abc目录的大小，不看其他目录12345678910#du -ch abc|tail -n 1-c 表示会列出文件空间大小的总和，用于计算几个文件的大小之和# du -sh abc-s表示总结的意思，即只列出一个目录中所有文件的空间大小的总值# du -h -max-depth=0 abc-max-depth＝n表示只深入到第n层目录，此处设置为0，即表示不深入到子目录。 列出abc目录及其子目录下所有目录和文件的大小 12# du -ah abc-a表示路径下的所有包括目录和文件 列出所有abc目录中的目录名不包括xyz字符串的目录的大小 1# du -h –exclude=’*xyz*’ 想在一个屏幕下列出更多的关于abc目录及子目录大小的信息 12# du -0h abc-0（杠零）表示每列出一个目录的信息，不换行，而是直接输出下一个目录的信息。]]></content>
      <categories>
        <category>常用linux命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[df命令]]></title>
    <url>%2F2018%2F04%2F17%2Fdf%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[dfdf命令作用是列出文件系统的整体磁盘空间使用情况。可以用来查看磁盘已被使用多少空间和还剩余多少空间。 df命令显示系统中包含每个文件名参数的磁盘使用情况，如果没有文件名参数，则显示所有当前已挂载文件系统的磁盘空间使用情况 在默认情况下，磁盘空间是以1KB为单位进行显示的，但是，如果POSIXLY_CORRECT环境变量被设置为true，这种情况下默认使用512字节为单位显示 df命令语法1df [选项] [文件名] 参数：12345678910111213141516-a：--all，显示所有的文件系统，包括虚拟文件系统-B：--block-size，指定单位大小。比如1k，1m等-h：--human-readable，以人们易读的GB、MB、KB等格式显示-H：--si，和-h参数一样，但是不是以1024，而是1000，即1k=1000，而不是1k=1024-i：--inodes，不用硬盘容量，而是以inode的数量来显示-k：以KB的容量显示各文件系统，相当于--block-size=1k-m：以KB的容量显示各文件系统，相当于--block-size=1m-l：--local，只显示本地文件系统--no-sync：在统计使用信息之前不调用sync命令(默认)-sync：在统计使用信息之前调用sync命令-P：--portability，使用POSIX格式显示-t：--type=TYPE，只显示指定类型的文件系统-T：--print-type，显示文件系统类型-x：--exclude-type=TYPE，不显示指定类型的文件系统--help：显示帮助信息--version：显示版本信息 df命令示例 示例1:查看包含给定文件磁盘空间使用情况12345678910111213141516171819[root@localhost ~]# df /home #指定一个文件夹，查看该文件夹所在磁盘的使用情况Filesystem 1K-blocks Used Available Use% Mounted on/dev/sda2 16036224 2749160 12459316 19% / [root@localhost ~]# df /bin/ls #指定一个文件Filesystem 1K-blocks Used Available Use% Mounted on/dev/sda2 16036224 2749160 12459316 19% / [root@localhost ~]# df /bin/ls /home #指定多个文件或文件夹Filesystem 1K-blocks Used Available Use% Mounted on/dev/sda2 16036224 2749160 12459316 19% //dev/sda2 16036224 2749160 12459316 19% / [root@localhost ~]# df # 默认情况Filesystem 1K-blocks Used Available Use% Mounted on/dev/sda2 16036224 2750464 12458012 19% //dev/sda1 295561 16911 263390 7% /boottmpfs 1028272 0 1028272 0% /dev/shm 输出结果列说明： Filesystem：代表该文件系统时哪个分区，所以列出的是设备名称。 1K-blocks：说明下面的数字单位是1KB，可利用-h或-m来改变单位大小，也可以用-B来设置。 Used：已经使用的空间大小。 Available：剩余的空间大小。 Use%：磁盘使用率。如果使用率在90%以上时，就需要注意了，避免磁盘容量不足出现系统问题，尤其是对于文件内容增加较快的情况(如/home、/var/spool/mail等)。 Mounted on：磁盘挂载的目录，即该磁盘挂载到了哪个目录下面。]]></content>
      <categories>
        <category>常用linux命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less命令]]></title>
    <url>%2F2018%2F04%2F16%2Fless%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[lessless 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。 在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按 键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。 1．命令格式：1less [参数] 文件 2．命令功能：less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 3．命令参数：1234567891011121314151617181920212223242526-b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 4．使用实例：实例1：ps查看进程信息并通过less分页显示同时显示行号1#ps -ef|less -N 实例2.浏览多个文件1#less test2.log test.log 说明：输入 ：n后，切换到 test.log输入 ：p 后，切换到test2.logps：当正在浏览一个文件时，也可以使用 :e命令 打开另一个文件。命令：less file1:e file2 5．附加备注5.1.全屏导航1234ctrl + F - 向前移动一屏ctrl + B - 向后移动一屏ctrl + D - 向前移动半屏ctrl + U - 向后移动半屏 5.2.单行导航12j - 向前移动一行k - 向后移动一行 5.3.其它导航123G - 移动到最后一行g - 移动到第一行q / ZZ - 退出 less 命令 5.4.其它有用的命令123v - 使用配置的编辑器编辑当前文件h - 显示 less 的帮助文档&amp;pattern - 仅显示匹配模式的行，而不是整个文件 6.标记导航123当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：ma - 使用 a 标记文本的当前位置'a - 导航到标记 a 处 7.查找1more, less 都具备查找功能，按/ 然后输入要找的字串，再按 Enter 即可，按 n(next) 会继续找，大写的 N 则是往回(上)找，按 q(quit)或者ZZ离开]]></content>
      <categories>
        <category>常用linux命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[more命令]]></title>
    <url>%2F2018%2F04%2F15%2Fmore%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[moremore功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。 1．命令格式：1more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] 2．命令功能：more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。 3．命令参数：123456789+n 从笫n行开始显示-n 定义屏幕大小为n行+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能-l 忽略Ctrl+l（换页）字符-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似-s 把连续的多个空行显示为一行-u 把文件内容中的下画线去掉 4．常用操作命令：123456789Enter 向下n行，需要定义。默认为1行Ctrl+F 向下滚动一屏空格键 向下滚动一屏Ctrl+B 返回上一屏= 输出当前行的行号：f 输出文件名和当前行的行号V 调用vi编辑器!命令 调用Shell，并执行命令 q 退出more 5．命令实例：实例1：显示文件中从第3行起的内容命令：12# cat test.log #显示所有日志内容# more +3 test.log #从第三行开始显示日志内容 实例2.将日志内容设置为每屏显示4行命令：1# more -4 test.log 实例3.从文件中查找第一个出现”liu”字符串的行，并从该处前两行开始显示输出命令：1#more +/liu test.log 实例4.当一个目录下的文件内容太多，可以用more来分页显示。这得和管道 | 结合起来命令：1#cat test.log | more -5 #“|”表示管道，作用是可以将前面命令的输出当做后面命令的输入]]></content>
      <categories>
        <category>常用linux命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tail命令]]></title>
    <url>%2F2018%2F04%2F14%2Ftail%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[taillinux tail命令用途是依照要求将指定的文件的最后部分输出到标准设备，通常是终端，通俗讲来，就是把某个档案文件的最后几行显示到终端上，假设该档案有更新，tail会自己主动刷新，确保你看到最新的档案内容。 tail命令语法1tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ] [ File ] 参数解释：1234567-f 该参数用于监视File文件增长。-c Number 从 Number 字节位置读取指定文件-n Number 从 Number 行位置读取指定文件。-m Number 从 Number 多字节字符位置读取指定文件，比方你的文件假设包括中文字，假设指定-c参数，可能导致截断，但使用-m则会避免该问题。-b Number 从 Number 表示的512字节块位置读取指定文件。-k Number 从 Number 表示的1KB块位置读取指定文件。File 指定操作的目标文件名称 上述命令中，都涉及到number，假设不指定，默认显示10行。Number前面可使用正负号，表示该偏移从顶部还是从尾部開始计算。 tail可运行文件一般在/usr/bin/以下。 tail命令使用方法演示例子 1、tail -f filename 说明：监视filename文件的尾部内容（默认10行，相当于增加参数 -n 10），刷新显示在屏幕上。退出，按下CTRL+C。 2、tail -n 20 filename 说明：显示filename最后20行。 3、tail -r -n 10 filename说明：逆序显示filename最后10行。 补充： 跟tail功能相似的命令还有： cat 从第一行開始显示档案内容。 tac 从最后一行開始显示档案内容。 more 分页显示档案内容。 less 与 more 相似，但支持向前翻页 head 仅仅显示前面几行 tail 仅仅显示后面几行 n 带行号显示档案内容 od 以二进制方式显示档案内容]]></content>
      <categories>
        <category>常用linux命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[head命令]]></title>
    <url>%2F2018%2F04%2F13%2Fhead%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[headhead 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 就是看档案的结尾。 1．命令格式：1head [参数]... [文件]... 2．命令功能：head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 3．命令参数：1234-q 隐藏文件名-v 显示文件名-c&lt;字节&gt; 显示字节数-n&lt;行数&gt; 显示的行数 4．使用实例：实例1：显示文件的前n行命令：1head -n 5 log.log 实例2：显示文件前n个字节命令：1head -c 20 log.log 实例3：文件的除了最后n个字节以外的内容命令：1head -c -32 log.log 实例4：输出文件除了最后n行的全部内容命令：1head -n -6 log.log]]></content>
      <categories>
        <category>常用linux命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ls命令]]></title>
    <url>%2F2018%2F04%2F12%2Fls%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[ls (list,列表)作用：使用列表把当前文件夹下所有文件夹显示出来 命令格式：1ls [选项] [目录名] 常用举例：1ls -a 列出文件下所有的文件，包括以“.“开头的隐藏文件 1ls -l 列出文件的详细信息，将文件的权限、所有者、文件大小等信息详细列出来 1ls -F 在每一个文件的末尾加上一个字符说明该文件的类型。"@"表示符号链接、"|"表示FIFOS、"/"表示目录、"="表示套接字。 1ls -s 在每个文件的后面打印出文件的大小。 size(大小) 1ls -t 按时间进行文件的排序 Time(时间) 1ls -A 列出除了"."和".."以外的文件。 1ls -R 将目录下所有的子目录的文件都列出来，相当于我们编程中的“递归”实现 1ls -L 列出文件的链接名。Link（链接） 1ls -S 以文件的大小进行排序 命令：ls -l t* 可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单。 命令：ls -ltr s* 列出目前工作目录下所有名称是s 开头的档案，越新的排越后面。 命令：ls -AF 列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档案于名称后加”*” 输出：123[root@localhost opt]# ls -AFlog/ script/ soft/ src/ svndata/ web/ 计算当前目录下的文件数和目录数 命令：123ls -l * |grep "^-"|wc -l ---查看文件个数 ls -l * |grep "^d"|wc -l ---查看目录个数 彩色目录列表颜色的含义如下: 1234567891. 蓝色--&gt;目录2. 绿色--&gt;可执行文件3. 红色--&gt;压缩文件4. 浅蓝色--&gt;链接文件5. 灰色--&gt;其他文件]]></content>
      <categories>
        <category>常用linux命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwd命令]]></title>
    <url>%2F2018%2F04%2F11%2Fpwd%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[pwd（print work directory 打印工作目录）作用：打印出当前的绝对路径 命令格式：1pwd [选项] 不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置 常用举例：1234[root@localhost /]# cd /opt/data/[root@localhost data]# pwd/opt/data[root@localhost data]# 目录连接链接时，pwd -P 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径 命令：1pwd -P 输出： 1234567891011[root@localhost soft]# cd /etc/init.d [root@localhost init.d]# pwd/etc/init.d[root@localhost init.d]# pwd -P/etc/rc.d/init.d[root@localhost init.d]#]]></content>
      <categories>
        <category>常用linux命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cd命令]]></title>
    <url>%2F2018%2F04%2F10%2Fcd%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[cd (change directory,更改目录)作用：用来切换目录 【涉及到相对路径和绝对路径 命令格式：1cd [目录名] 跳转到指定目录，从根目录开始，目录名称前加 / ,当前目录内的子目录直接写名称即可. 常用举例：1cd /opt/soft 进入到/opt/soft 1cd / 进入系统根目录 1cd ~ 进入当前用户主目录 1cd . . 代表当前目录 1cd .. .. 代表上一层目录 1cd - 返回上次所在目录 1cd ../.. 返回上两级目录]]></content>
      <categories>
        <category>常用linux命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端口被占用问题]]></title>
    <url>%2F2016%2F11%2F15%2F%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[当我们同时安装了Oracle和Tomcat的时候，Tomcat启动时就会报错说端口被占用了。那么如何来解决呢?两种方法： 第一种方法就是修改我们的Tomcat的端口号，改成其他不冲突的即可。方便简单 第二种方法就是结束当前占用端口的进程，下面是具体步骤： 以我电脑进程为例： 1.打开cmd 输入 netstat -ano|findstr 8080 //说明：查看占用8080端口的进程 2.接着输入 taskkill /pid 2956 /f 2956是占用端口的进程 //说明：结束掉占用端口号的进程 但是呢这种方法只能是一时的，下次启动还是会占用的。个人认为修改端口较好。一次解决。]]></content>
      <categories>
        <category>学习中遇到问题及解决方法</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4天static静态关键字和单例模式]]></title>
    <url>%2F2015%2F12%2F01%2F%E7%AC%AC4%E5%A4%A9static%E9%9D%99%E6%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、static关键字1.static关键字修饰在属性上 语法 语法：static数据类型 变量名 使用static修饰的属性我们认为是类的属性，不带static修饰的属性我们认为是对象的属性。 类属性访问 类的属性访问： 第一种方式：类名.类属性（推荐使用） 第二种方式：对象实例.类属性 应用场景 应用的场景：我们把常量一般定义成static，或者当前类创建的每一个对象都有相同的属性也可以把这种属性定义成static的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Person&#123; /** name和age都是对象属性 */ String name; int age; /** 人的数量，类属性 */ static int personNum; //static String file_name = "struts.xml" public void introduce()&#123; //通过对象实例来访问类属性 System.out.println("我叫"+this.name+"年龄是"+this.age+"编号"+this.personNum+"报到"); &#125; &#125;class StaticDemo&#123; public static void main(String [] args)&#123; //创建一个person的实例 Person p = new Person(); //给人的数量加一 Person.personNum++; p.name = "周铭艳"; p.age = 18; p.introduce(); //创建一个person的实例 Person p1 = new Person(); //给人的数量加一 Person.personNum++; p1.name = "鲁达"; p1.age = 30; p1.introduce(); //通过类名来访问类的属性 System.out.println("当前人数："+Person.personNum); //通过对象实例来访问类属性 System.out.println("当前人数："+p.personNum); &#125;&#125; 内存中的加载流程 上述代码在内存中的流程 生命周期 对象属性生命周期：创建对象的时候初始化对象属性（没有类属性早），当当前对象变成匿名对象时，jvm会回收该垃圾对象，对象属性随之消失。 类属性的生命周期：当Person.class被载入内存时personNum类属性就初始化了，jvm关闭类属性就消失了 二、static关键字修饰在方法上 语法 语法：public static 返回值（void） 方法名（数据类型1 变量1，数据类型2 变量2，….）{ 方法体 [return 结果]} Static修饰在方法上就是类方法。 类方法的访问 类方法访问： &lt;font color=&apos;red&apos;&gt;第一种方式：类名.类方法()推荐使用&lt;/font&gt; 第二种方式：对象实例.类方法() 类方法对属性的访问 访问对象属性：类方法是无论是通过类访问还是通过对象访问都不能直接访问对象属性的 12345678910111213class Demo&#123; int num = 50; static int num1 = 100; //类方法 public static void printNum()&#123; //System.out.println("我是一个静态方法"); System.out.println(num); &#125; &#125; 类方法对类属性的访问： 类方法对类属性的访问是可以的。 注意：对象方法和属性只能通过对象来调用。 类方法和类属性既可以通过类来调用也可以通过对象来调用。 类方法应用场景： 做工具类 做数组的工具类12345678910111213141516171819202122232425262728293031323334353637class ArrayUtils&#123; public static void sort(int [] array)&#123; for(int i = 0; i &lt; array.length -1 ; i++)&#123; for(int j = 0; j &lt; array.length - 1 -i; j++)&#123; if(array[j] &lt; array[j+1])&#123; int temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125; &#125; public static void printArray(int [] array)&#123; for(int i = 0; i &lt; array.length; i++)&#123; System.out.print(array[i]+"\t"); &#125; &#125; public static void main(String [] args)&#123; int [] array = &#123;97,12,190, 4, 52,98&#125;; //ArrayUtils.printArray(array); //ArrayUtils.sort(array); System.out.println(); //ArrayUtils.printArray(array); //在同一个类中可以不加类名去访问静态方法。如果是不同类之间来访问静态方法必须加类名 printArray(array); sort(array); System.out.println(); printArray(array); &#125;&#125; 2.单例模式设计模式：一共有23种设计模式 设计模式就是有经验的前人通过实践总结下来被大家公认的代码设计思想。 单例模式：这种模式只能产生一个对象。 应用场景非常多：比如windows的任务管理器，回收站，java中数据库连接池，spring中bean的管理等等。 1.单例模式的创建步骤 （1）将默认的构造器私有化 （2）在类中定义一个当前类的类型的静态属性，并且创建该当前类的对象。 （3）提供一个静态的类方法来返回当前类的静态属性的对象。 懒汉模式 12345678910111213141516171819202122232425262728293031323334/** 懒汉模式*/class Singleton&#123; private static Singleton s = new Singleton(); /** 创建私有构造器 */ private Singleton()&#123; &#125; /** 提供一个共外界来获得当前类的一个实例的类方法 注意：类方法所访问的类的属性一定是类属性 */ public static Singleton getInstance()&#123; return s; &#125;&#125;class TestSingleton&#123; public static void main(String [] args)&#123; Singleton s = Singleton.getInstance(); System.out.println(s); Singleton s1 = Singleton.getInstance(); System.out.println(s1); &#125;&#125; 饿汉模式 12345678910111213141516171819202122232425262728293031323334353637/** 饿汉模式*/class Singleton1&#123; private static Singleton1 s = null; /** 创建私有构造器 */ private Singleton1()&#123; &#125; /** 提供一个共外界来获得当前类的一个实例的类方法 注意：类方法所访问的类的属性一定是类属性 */ public static Singleton1 getInstance()&#123; if(s == null)&#123; s = new Singleton1(); &#125; return s; &#125;&#125;class TestSingleton1&#123; public static void main(String [] args)&#123; Singleton1 s = Singleton1.getInstance(); System.out.println(s); Singleton1 s1 = Singleton1.getInstance(); System.out.println(s1); &#125;&#125;]]></content>
      <categories>
        <category>Java基础笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3天程序的流程控制]]></title>
    <url>%2F2015%2F11%2F18%2F%E7%AC%AC3%E5%A4%A9%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、判断结果 简单if 语法：if(条件判断表达式){ 执行语句 }如果条件判断的表达式返回值是true则可以执行if内部的语句，否则如果是false就不可以执行。 范例1：如果java考试成绩大于等于60及格 1234567891011121314class Demo1&#123; public static void main(String[] args)&#123; int score = 70; if(score &gt;= 60)&#123; System.out.println("及格"); &#125; System.out.println("程序结束"); &#125;&#125; if…else 语法：if(条件判断表达式){ 执行语句 }else{ 执行语句} 范例2：如果java考试成绩大于60及格，否则是不及格 12345678910111213141516class Demo1&#123; public static void main(String[] args)&#123; int score = 10; if(score &gt;= 60)&#123; System.out.println("及格"); &#125;else&#123; System.out.println("不及格"); &#125; System.out.println("程序结束"); &#125;&#125; 多重 if….else if…else 语法：if(条件判断表达式){ 执行语句 }else if(条件表达式1){ 执行语句 }else if(条件表达式2){ ….. }else{} 范例3：如果大于等于60小于等于85及格，大于等于85小于100优秀，如果等于100完美，其余的不及格。 1234567891011121314151617181920class Demo1&#123; public static void main(String[] args)&#123; int score = 100; if(score &gt;= 60 &amp;&amp; score &lt; 85)&#123; System.out.println("及格了"); &#125;else if(score &gt;= 85 &amp;&amp; score &lt; 100)&#123; System.out.println("优秀"); &#125;else if(score == 100)&#123; System.out.println("完美"); &#125;else&#123; System.out.println("不及格"); &#125; System.out.println("程序结束"); &#125;&#125; 范例: 如果工资大于3000D级，大于5000C级，大于7000B级，大于10000A级通过简单if组合的形式 1234567891011121314151617181920212223242526class Demo2&#123; public static void main(String[] args)&#123; int salary = 7000; if(salary &gt;= 3000 &amp;&amp; salary &lt; 5000)&#123; System.out.println("D级"); &#125; if(salary &gt;= 5000 &amp;&amp; salary &lt; 7000)&#123; System.out.println("C级"); &#125; if(salary &gt;= 7000 &amp;&amp; salary &lt; 10000)&#123; System.out.println("B级"); &#125; if(salary &gt;= 10000)&#123; System.out.println("A级"); &#125; &#125;&#125; 通过多重if实现 二、Switch分支判断Switch：由上到下用switch中的表达式和值进行比较，如果匹配成功就执行case后的语句，在执行break的时跳出switch，如果一个也没有匹配上就执行default默认情况。 Switch（表达式）{ case 常量1： 执行语句1； break； case 常量2： 执行语句2； break； …..default:执行语句 ；break；} 范例1：通过等级打印不同星1234567891011121314151617181920212223242526272829303132333435class Demo4&#123; public static void main(String[] args)&#123; /*** 等级1用☆ 等级2用☆☆ 等级3用☆☆☆ 等级4用☆☆☆☆ 等级4用☆☆☆☆☆ */ int grade = 0; switch(grade)&#123; case 1: System.out.println("☆"); break; case 2: System.out.println("☆☆"); break; case 3: System.out.println("☆☆☆"); break; case 4: System.out.println("☆☆☆☆"); break; case 5: System.out.println("☆☆☆☆☆"); break; default: System.out.println("输入错误"); break; &#125; &#125;&#125; Break可以省略不会报错，如果省略就会穿透执行语句（不管是否能匹配上），知道遇到一个break才会跳出，所以我们不建议省略break。 在jdk1.7之前，swtich的表达式只能是byte, short, char, int,但是1.7后可以使用String 范例2：计算指定年的月中有多少天123456789101112131415161718192021222324252627282930313233343536373839class Demo5&#123; public static void main(String[] args)&#123; //计算每一年的每一月有几天 int year = 2000; int month = 2; int day = 0; switch(month)&#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: day = 31; break; case 4: case 6: case 9: case 11: day = 30; break; case 2: if((year%400) == 0 || (year%4 == 0&amp;&amp; year%100 != 0))&#123; day = 29; &#125;else&#123; day = 28; &#125; break; default: break; &#125; System.out.println(year + "年"+ month+"月有"+day+"天"); &#125;&#125; 注意： Switch和多重if的区别： If可以做等值判断也可以做区间判断。 Switch只能做等值判断，不能做区间判断 三元运算符 语法：表达式1 关系运算符 表达式2？表达式3：表达式4 ？前面的表达式2如果运算的结果是true，整个表达式的结果就是表达式3 ？前面的表达式2如果运算的结果是false，整个表达式的结果就是表达式4 注意：三元运算符适合两个值的判断 12345678910111213141516171819202122class Demo6&#123; public static void main(String[] args)&#123; //如果gender=1我们genderText就是男，如果gender=2那么genderText=女 int gender = 1; char genderText = ' '; /* if(gender == 1)&#123; genderText = '男'; &#125;else if(gender == 2)&#123; genderText = '女'; &#125; System.out.println(genderText); */ //表达式1 赋值 表达式2 genderText = gender == 1?'男':'女'; System.out.println(genderText); &#125;&#125; 循环结构 循环：就是重复发生的过程（循环一般有重复的前提条件）。1.While语法：while(表达式){ 循环体 }表达式结果如果是true那么就执行循环体，如果是false就结束循环 范例：1123456789101112131415161718192021class Demo7&#123; public static void main(String[] args)&#123; /* 打印1到100之间的数字 分析： 循环条件：是否完成打印100次 循环操作：输出，自增 */ //循环变量，计数器 int i = 1; while(i &lt;= 100)&#123; System.out.println(i); //更改循环条件 i++; &#125; &#125;&#125; 范例：212345678910111213141516171819202122232425262728class Demo8&#123; public static void main(String[] args)&#123; /* 需求：打印1到100之间的所有的偶数和 分析： 循环条件：判断计数器是否小于等于100 循环操作：累加偶数和，更新计数器 */ //定义计数器 int i = 0; //定义偶数和的结果变量 int sum = 0; while(i &lt;= 100)&#123; //判断i是否是偶数 if(i%2 == 0)&#123; //累加偶数 sum += i; &#125; //更新计数器 i++; &#125; System.out.println(sum); &#125;&#125; do…while语法：*do{循环体 }while(表达式) 注意：do…while和while，前者是先执行循环体，后者是先判断在执行循环体。 范例1：123456789101112131415161718192021222324252627282930class Demo9&#123; public static void main(String[] args)&#123; /* 需求：打印100到1000之间的所有水仙花数。 234 分析： 循环条件：判断计数器是大于等于100小于1000 循环操作：更新计数器，判断是否是水仙花数。 */ int i = 100; do&#123; //获得个位数 int g = i%10; //获得十位数 int s = i/10%10; //获得百位数 int b = i/100; //判断是否是水仙花数 if((g*g*g + s*s*s + b*b*b) == i)&#123; System.out.println(i); &#125; i++; &#125;while(i &lt; 1000); &#125;&#125; 范例2：123456789101112131415161718192021222324252627282930class Demo10&#123; public static void main(String[] args)&#123; /* 需求：打印100到1000之间的所有夹心饼数。 如：191,838 分析： 循环条件：判断计数器是大于等于100小于1000 循环操作：更新计数器，判断是否是夹心饼干 */ int i = 100; do&#123; //获得个位数 int g = i%10; //获得百位数 int b = i/100; //判断是否是水仙花数 if(g == b)&#123; System.out.println(i); &#125; i++; &#125;while(i &lt; 1000); &#125;&#125; for 语法：for(表达式1; 表达式2; 表达式3){ 循环体 } 表达式1：计数器的初始化，它只初始化一次 表达式2：循环条件的判断，多次执行 表达式3：修改计数器，多次执行 范例1：1234567891011121314151617181920212223class Demo11&#123; public static void main(String[] args)&#123; /* 需求：打印1到100之间的所有的偶数和 分析： 循环条件：判断计数器是否小于等于100 循环操作：累加偶数和，更新计数器 */ //定义偶数和的结果变量 int sum = 0; for(int i = 0; i &lt;= 100; i++)&#123; if(i%2 == 0)&#123; sum += i; &#125; &#125; System.out.println(sum); &#125;&#125; 范例2：打印一个5行5列的☆12345678910111213141516171819202122class Demo12&#123; public static void main(String[] args)&#123; /* 需求：打印5行5列 的☆ 分析： 我们要使用2个循环 循环条件：判断计数器是否小于等于100 循环操作：累加偶数和，更新计数器 */ //定义偶数和的结果变量 for(int i = 0; i &lt; 5; i++)&#123; for(int j = 0; j &lt; 5; j++)&#123; System.out.print("☆"); &#125; System.out.println(); &#125; &#125;&#125; 范例2：打印乘法口诀1231*1=11*2=2 2*2=41*3=3 2*3=6 3*3=9 12345678910111213141516171819202122class Demo13&#123; public static void main(String[] args)&#123; /* 范例2：打印乘法口诀 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 ….. */ for(int i = 1; i &lt;=9; i++)&#123; for(int j = 1; j &lt;= i; j++)&#123; System.out.print(j+"*"+i+"="+j*i+"\t"); &#125; System.out.println(); &#125; &#125;&#125; 总结： 最重要的循环是while和for 如果循环开始之前就能确定循环次数我们建议使用for 如果循环次数不定建议使用while break Break用来跳出循环和switch12345678910111213141516171819class Demo14&#123; public static void main(String[] args)&#123; /** 需求：运动会上跑5000米，跑到第三圈时，抽筋了退赛 */ for(int i = 1; i &lt;= 10; i++)&#123; if(i == 3)&#123; System.out.println("抽筋了退出"); //跳出循环 break; &#125; System.out.println("我跑到第"+i+"圈"); &#125; &#125;&#125; continue 也是来控制循环，在某次循环的时候放弃，后续的接着循环。123456789101112131415161718class Demo15&#123; public static void main(String[] args)&#123; /** 需求：一周上五天班，然后我周三请假一天 */ for(int i = 1; i &lt;= 5; i++)&#123; if(i == 3)&#123; System.out.println("周三肚子疼请假"); //跳出本次循环，接着下一次循环 continue; &#125; System.out.println("今天星期"+i+"上班"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java基础笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2天Java基础语法]]></title>
    <url>%2F2015%2F11%2F11%2F%E7%AC%AC2%E5%A4%A9Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、标识符 在java语言中，对各种变量，方法和类等要素命名时所使用的字符序列就是标识符。这些标识符有jdk定义好的，也有我们自己开发时候需要定义的. java中标识符由26个英文字符大小写，数字0-9，符号_ $。注意：数字不能开头。 java中是严格区分大小写 在实际写程序的过程中定义标识符遵守“见名之意”. 类名和接口的规范： 在上面的约束的命名规范的情况下，首字符要大写。如果由多个单词构成每个单词的首字符都大写。 XxxYyy 如：PersonService 变量名和方法名： 在上面的约束的命名规范的情况下，我们遵守单词首字符不要大写，如果由多个单词构成，从第二个单词起首字符都大写。这叫驼峰模式。 xxxYyyZzz 如：personDao 包名在上面的约束的命名规范的情况下，都小写。 xxx.yyy.zzz 常量 所有字符都大写，多个单词之间使用下划线来分隔。 XXX_YYY_ZZZ 二、关键字Jdk定义的标识符就是关键字，我们不可以使用。所以我们定义标识符的时候一定要避开关键字。 三、java中的注释注释就是给程序说明的作用，我们要养成写注释的良好习惯，增强代码的可读性。Jvm运行时注释不会被解析。Jvm会跳过注释。 多行注释：/…./,通常用于方法内的多行或者类的多行注释 1234567891011/*public static void main(String[] args)&#123; System.out.println("HelloWorld1"); System.out.println("HelloWorld1"); System.out.println("HelloWorld1"); System.out.println("HelloWorld1"); System.out.println("HelloWorld1"); &#125;*/ 单行注释语法：//，注释代码中的一行，建议大家放在要注释的代码的上面 文档注释：语法/*../,用于类的说明和方法的说明 1234567891011121314151617181920212223/** *这是我们第一个HelloWorld的程序 */class HelloWorld&#123; /** *这是这是我们的主方法 */ public static void main(String[] args)&#123; //输出helloWorld System.out.println("HelloWorld1"); //输出helloWorld1 System.out.println("HelloWorld1"); /* System.out.println("HelloWorld1"); System.out.println("HelloWorld1"); System.out.println("HelloWorld1"); */ &#125;&#125; 四、数据类型1.基本数据类型 基本数据类型概述 根据不同的数据类型可以划分内存的存储的空间大小，不同的类型就是数据类型 整数的基本类型 byte 最小存储整数的空间 1字节 short 2字节 int 4字节 long 最大存储整数的空间 8字节 byte和short计算时产生的结果默认是int类型 小数的基本类型 flout 4字节 double 8字节 如果整型数据在计算的时候结果出现了小数，结果类型默认是double 建议使用double 字符数据类型char 2字节如：‘a‘，’周‘ 布尔数据类型 boolean true false 一共8种数据类型。 定义变量 语法：数据类型 变量名 = 值; 我们对变量的操作：取值和存值。1234567class Demo1&#123; public static void main(String[] args)&#123; //数据类型 变量名 = 值; int age = 10; System.out.println(age); &#125; &#125; 变量的定义位置：定义在方法中或者语句块中。 变量的一定要赋初始值，否则使用该变量的时候会报错的。 变量的作用范围：只在当前的大括号内有效，大括号外的所有程序不能使用该变量，所以这种变量也称为局部变量。123456789101112131415161718192021222324252627282930313233343536class Demo2&#123; public static void main(String[] args)&#123; //字节数据类型 byte workYear = 10; //短整型 short salary = 2000; //数据类型 变量名 = 值; int age = 30; //长整型,在定义长长整型的数据时在值后面加上l long empTime = 10000000l; //小数类型float,float类型的数值后面一定要有f float price = 45.6f; //小数类型double,建议在值的后面加d double totalPrice = 10000.5d; //布尔数据类型 boolean isMarry = false; //字符类型 char sex = '男'; System.out.println("工作年限："+workYear); System.out.println("月薪："+salary); System.out.println("年龄："+age); System.out.println("入职时长："+empTime); System.out.println("单价："+price); System.out.println("总价："+totalPrice); System.out.println("是否结婚："+isMarry); System.out.println("性别："+sex); &#125; &#125; 这八种数据类型是有默认值的。这个默认值如果在变量中不能使用的，必须是在类的属性中使用，因为类的属性可以不赋初始化值。 基本数据类型转换 八种数据类型除了布尔类型以外都可以相互的转换。 1.自动类型转换 基本数据类型在计算的时候都会向数值范围大的方向转换 byte—short–int —-long–float—double 所有的byte类型和short类型和char值运算的时候都会提供成int类型。 如果计算中一个操作数据类型是long，另一个数的空间小于等于long，那么结果就是long 如果计算中一个操作数据类型是float，另一个数的空间小于等于float，那么结果就是float 如果计算中一个操作数据类型是double，另一个数的空间小于等于double，那么结果就是double 2.强制转换 当大容量类型的变量向小容量的类型去转换需要强制转换。 语法：（目标类型）值1234567891011121314151617181920212223242526272829//在java程序中同一个范围内变量名字不能重复 int i3 = 97; //把int类型的数据强制转换成byte byte b3 = (byte)i3; //把int类型的数据强制转换成short short s3 = (short)i3; //把int类型的数据强制转换成char char c3 = (char)i3; System.out.println(b3); System.out.println(s3); System.out.println(c3); int i4 = 200; //注意如果被转换的值超过了要转换的值的最大值，转换时精度就损失了，不准确。 byte b4 = (byte)i4; System.out.println(b4); //把long类型的数据转换成int long l4 = 10000l; int i5 = (int)l4; System.out.println(i5); //把小数float转换成整型，直接把小数舍弃（非四舍五入） float f1 = 12.5f; int i6 = (int)f1; System.out.println(i6); //把小数double转换成整型，直接把小数舍弃（非四舍五入） double d1 = 15.5f; int i7 = (int)d1; System.out.println(i7); 思考： byte b1 = 3，b2=4, b; b = b1 + b2;//报错，因为byte类型计算完毕后会自动提升为int类型。 b= 4+3;//不会报错，因为int类型的常量相加只要没有达到byte的上限就可以。 2.引用数据类型 五、运算符 算数运算符 四则运算：+，-，*，/ 给数值变量自身加1或减一 123456789101112131415161718192021222324252627282930313233343536373839class Demo4&#123; public static void main(String[] args)&#123; //定义两个int类型的变量 int a = 30; int b = 20; System.out.println("a+b="+(a+b)); System.out.println("a-b="+(a-b)); System.out.println("a*b="+(a*b)); //整数之间做除法叫取整30/20=1.5,要把小数位舍弃 System.out.println("a/b="+(a/b)); //++, -- //a++起到了给a加1的作用 a++; //会输出a加1之后的值 System.out.println(a); //a--起到了给a减1的作用 a--; //会输出a减一1之后的值 System.out.println(a); //如果我后++或者后--和用变量在同一句代码中使用，是先使用a变量，再做加1或者减一 System.out.println(a--); System.out.println(a) //起到了给变量a加1的作用 --a; System.out.println(a); //如果我前++或者前--和用变量在同一句代码中使用，是先做加1或者减一，再使用a变量 System.out.println(--a); &#125; &#125; 赋值运算符 =，+=，-=，*=，/=, %= =：将左边的数值赋给右边的变量 +=：int x = 2；x+=3;相当于x=x+3 12345678910111213141516171819202122232425262728293031class Demo5&#123; public static void main(String[] args)&#123; //把20这个值赋给a变量 int a = 20; //+=,相当于a = a + 5; //a = a + 5; a+=5; System.out.println(a); //-=,相当于a = a - 5; a-=5; System.out.println(a); //*=,相当于a = a * 5; a*=5; System.out.println(a); ///=,相当于a = a / 5; a/=5; System.out.println(a); //%=,相当于a = a % 5; a%=5; System.out.println(a); &#125; &#125; 比较运算符 ==，!=, &gt;, &gt;=, &lt;, &lt;= ==:等于 !=:不等于 &gt;:大于 &gt;=:大于等于&lt;:小于&lt;=:小于等于 12345678910111213141516171819class Demo6&#123; public static void main(String[] args)&#123; int a = 19; int b = 10; //比较运算符的结果是布尔类型true，false System.out.println("a==b:"+(a==b)); System.out.println("a!=b:"+(a!=b)); System.out.println("a&gt;b:"+(a&gt;b)); System.out.println("a&lt;b:"+(a&lt;b)); System.out.println("a&gt;=b:"+(a&gt;=b)); System.out.println("a&lt;=b:"+(a&lt;=b)); &#125; &#125; 逻辑运算符 &amp;，|，^, &amp;&amp;, ||，！ 应用场景：如果某个结果需要多个条件满足或者部分条件满足的判断时使用。 &amp;: 用于连接多个表达式的判断，true&amp;true=true，&amp;两边的表达式都要参与计算。 |:用于连接多个表达式的判断，false|false=false, &amp;两边的表达式都要参与计算 短路逻辑（效率高） &amp;&amp;:用于连接多个表达式的判断, true&amp;&amp;true=true，如果第一个表达式能决定整个表达式的结果第二个表达式就不计算了。 ||:用于连接多个表达式的判断, false||false=false，如果第一个表达式能决定整个表达式的结果第二个表达式就不计算了。^:用于连接多个表达式的判断,如果两个表达式相同就是false，不同是true，两边都参加计算 （了解）！：取反 12345678910111213141516171819202122232425class Demo7&#123; public static void main(String[] args)&#123; int java = 90; int sql = 70; //只有java和sql打分都大于90分才合格 //System.out.println(java&gt;=90&amp;(sql++) &gt;= 90); //System.out.println(java&gt;=90|(sql++) &gt;= 90); //短路与，如果第一个表达式是false，后面的表达式就不需要判断了，效率高 //System.out.println(java&gt;=90&amp;&amp;(sql++) &gt;= 90); //短路或，如果第一个表达式是true，后面的表达式就不需要判断了，效率高 //System.out.println(java&gt;=90||(sql++) &gt;= 90); //异或了解 //System.out.println(java&gt;=90^(sql++) &gt;= 90); //System.out.println(sql); //如果对于表达式取反需要通过括号括上。 System.out.println(!(java &gt; 80)); &#125; &#125;]]></content>
      <categories>
        <category>Java基础笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1天计算机基础初识JAVASE]]></title>
    <url>%2F2015%2F10%2F15%2F%E7%AC%AC1%E5%A4%A9%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%88%9D%E8%AF%86JAVASE%2F</url>
    <content type="text"><![CDATA[一、计算机语言概述计算机能识别的语言： 机器语言：由0和1组成的可以被电脑理解，人很难理解。 汇编语言：由汇编软件把汇编语言翻译成机器语言然后电脑可以理解，人可以理解。 高级语言：与人类的自然语言很接近，由高级语言的编译器来把高级语言翻译成机器语言，然后计算机来运行，java，c，c++,…. 二、Java概述1995年诞生于sun公司，2009被Oracle收购。 Java语言的特点： 简洁有效：面向对象，简单易学。 java跨平台：java写好的程序可以在不同平台来运行，一次编译处处运行。Java为每一个平台提供jvm（java virtual machine）。 适合分布式计算：java语言具有强大的，易于使用的互联网能力，非常适合大型的互联网分布式项目。 Java分支 javase: 前身j2se,2005年后改成javase javame：前身是j2me,2005改成javame，给移动设备做支持，目前基本上淘汰了。 javaee：前身j2ee，企业级应用技术开发支持 三、Java开发环境的介绍和搭建 JRE：java runtime environment java运行环境，JRE包括java虚拟机（jvm java virtual machine）和java程序所需要核心的类库。如果先要运行java程序，计算机中安装JRE就可以了。 JDK：java development kit JDK是给开发人员使用的，JDK包含了JRE，所以我们只要安装JDK就可以了。 JDK的安装 注意，安装JDK时不要有中文路径。 环境变量的介绍 配置环境变量步骤： 此电脑右键属性——高级系统设置—–高级——-环境变量 用户范围的环境变量：给当前操作系统登录的用户使用系统环境变量：给所有用户使用。 环境变量的配置：当我们在命令行中执行javac的时候，我们发现无法执行，就是因为当前的目录下没有javac的命令。如果想要在任意目录执行我们必须配置环境变量Path，path中的路径就是我们可以在任意的目录来执行程序，如果当前目录不存在程序就去path中去查找 环境变量的第二种配置方式（强烈推荐使用） 首先创建java_home: C:\Program Files\Java\jdk1.7.0_45指定bin的上一层目录然后在path中通过%%来引入java_home,然后在path中指定bin的目录 建议把环境变量配置在用户的环境变量中。 第一个java程序HelloWorld 推荐大家使用UtralEditor Java文件是以.java为后缀，类名要和文件名一致，类名的首字母要大写，然后在类中写入主方法，大括号一定是成对出现，类和方法之间要有缩进，方法和方法体之间也要有缩进，缩进使用Tab键，不要使用空格。除了带有大括号的代码行，每一行结尾都要有分号 12345678910class HelloWorld&#123;/** 主方法*/public static void main(String[] args)&#123;//输出字符串HelloWorldSystem.out.println("HelloWorld"); &#125;&#125; Java文件是不能直接运行的，必须要编译成.class二进制文件，然后才能运行。我们需要开启命令行来编译和运行。]]></content>
      <categories>
        <category>Java基础笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2015%2F10%2F02%2FHello-World%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
